<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- START: Meta tags for app-like full-screen mode on mobile -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- END: Meta tags -->
    <title>Go! Go! Monkey, Go!</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            touch-action: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        // START: Added for mobile-specific logic
        const isMobileOrTablet = window.matchMedia("(max-width: 1024px)").matches;
        const speedMultiplier = isMobileOrTablet ? 1.2 : 1.0;
        // END: Added for mobile-specific logic
        
        const MOBILE_CHAR_SELECT_SCALE = 0.9; 

        const MOBILE_SCALE_FACTOR = 1.1;
        const scaleFactor = isTouchDevice ? MOBILE_SCALE_FACTOR : 1.0;

        const BASE_GAME_WIDTH = 800;
        const BASE_GAME_HEIGHT = 1200;
        let GAME_WIDTH = BASE_GAME_WIDTH;
        let GAME_HEIGHT = BASE_GAME_HEIGHT;


        // --- Game Music & Sounds ---
        const bgMusic = new Audio('https://nerdrealm419.github.io/Go-Go-Monkey-Go-v1/jungle-jive-intro.mp3');
        const jumpSound = new Audio('https://nerdrealm419.github.io/Go-Go-Monkey-Go-v1/cartoon-jump-6462.mp3');
        const sparkleSound = new Audio('https://nerdrealm419.github.io/Go-Go-Monkey-Go-v1/sparkle-355937.mp3');
        bgMusic.loop = true;
        bgMusic.volume = 0.0035;
        sparkleSound.volume = 0.004;
        jumpSound.volume = 0.004;
        let musicStarted = false;
        let isMuted = false;

        // --- Constants ---
        // START: Modified for mobile speed increase
        const MONKEY_ACCELERATION = 750 * speedMultiplier, MONKEY_MAX_SPEED = 330 * speedMultiplier, FRICTION = 0.89, GRAVITY = 1400 * speedMultiplier, JUMP_STRENGTH = 660 * speedMultiplier;
        const BOOSTED_ACCELERATION = 1100 * speedMultiplier, BOOST_DURATION = 5, BOOST_UP_FORCE = 0;
        const VINE_COUNT = 10, VINE_MIN_WIDTH = 140 * scaleFactor, VINE_MAX_WIDTH = 210 * scaleFactor, VINE_VERTICAL_SPACING = 125, VINE_FALL_TRIGGER_TIME = 15 / speedMultiplier, VINE_JUMPS_TO_BREAK = 3;
        const VINE_HORIZONTAL_REACH = 200, VINE_FALL_SPEED = 600 * speedMultiplier;
        const BANANA_SPAWN_CHANCE = 0.45, BANANA_POINTS = 750;
        const SPRINT_BANANA_SPAWN_CHANCE = 0.25;
        const SPRINT_BANANA_COOLDOWN = 15 / speedMultiplier;
        // END: Modified for mobile speed increase
        const SPECIAL_BANANA_POINTS = { 'nanners': 1000, 'peeley': 1250, 'bruiser': 1500, 'checkers': 1000, 'tako': 1250, 'ember': 1500 };
        const DAY_NIGHT_DISTANCE = 8600;
        const DIFFICULTY_SCORE_INTERVAL = 9000;
        const VINE_MIN_HORIZONTAL_OFFSET = 120;
        
        // --- Local Storage Keys & Migration ---
        const MIGRATION_FLAG_KEY = 'gogomonkeygo_scores_migrated_v3';
        const OLD_HIGH_SCORE_KEY = 'gogomonkeygo_highscores'; // Assumed key for original high score list
        const HIGH_SCORE_KEY = 'gogomonkeygo_highscores_classic';
        const NIGHT_HIGH_SCORE_KEY = 'gogomonkeygo_highscores_night';
        const NIGHT_HIGHEST_SCORE_KEY = 'gogomonkeygo_highestscore_night';
        const SPRINT_HIGH_SCORE_KEY_PREFIX = 'gogomonkeygo_sprint_highscores_';
        const UNLOCK_KEY = 'gogomonkeygo_highestscore';
        const MUTE_KEY = 'gogomonkeygo_muted';
        const NANNERS_UNLOCK_KEY = 'gogomonkeygo_nanners_unlocked';
        const PEELEY_UNLOCK_KEY = 'gogomonkeygo_peeley_unlocked';
        const BRUISER_UNLOCK_KEY = 'gogomonkeygo_bruiser_unlocked';
        const CHECKERS_UNLOCK_KEY = 'gogomonkeygo_checkers_unlocked';
        const TAKO_UNLOCK_KEY = 'gogomonkeygo_tako_unlocked';
        const EMBER_UNLOCK_KEY = 'gogomonkeygo_ember_unlocked';
        
        const MUTE_BUTTON_RECT = { x: GAME_WIDTH - 70, y: 15, w: 55, h: 55 };
        const MEDAL_COLORS = ['#FFD700', '#C0C0C0', '#CD7F32', '#00FFFF', '#FF69B4'];
        const MEDAL_EMOJIS = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰', 'ðŸ…', 'ðŸ…'];
        
        const CHARACTERS = {
            'orange':  { name: 'Go!Go!',   unlock: 0,      main: '#f96714', dark: '#ef5a06', face: '#ffdab9', pupils: '#000000' },
            'peach': { name: 'Peachy',  unlock: 20000,   main: '#ffb74d', dark: '#f57c00', face: '#fff3e0', pupils: '#000000' },
            'brown':   { name: 'CoCo',    unlock: 25000,   main: '#623412', dark: '#401801', face: '#d1bba1', pupils: '#000000' },
            'red':    { name: 'Ruby',   unlock: 35000,   main: '#d32f2f', dark: '#b71c1c', face: '#ffcdd2', pupils: '#000000' },
            'yellow':  { name: 'Sunny',   unlock: 40000,  main: '#dbc001', dark: '#fbc02d', face: '#fff9c4', pupils: '#000000' },
            'pink':    { name: 'Rose',    unlock: 45000,  main: '#f48fb1', dark: '#c2185b', face: '#fce4ec', pupils: '#e91e63' },
            'blue':    { name: 'Azul',    unlock: 50000,  main: '#42a5f5', dark: '#1565c0', face: '#bbdefb', pupils: '#0277bd' },
            'purple':  { name: 'Violet',  unlock: 55000,  main: '#971597', dark: '#6a1b9a', face: '#f6bbf6', pupils: '#320732' },
            'gray':    { name: 'Silver',  unlock: 60000,  main: '#9e9e9e', dark: '#616161', face: '#e0e0e0', pupils: '#000000', sparkles: true },
            'black':   { name: 'Shadow',  unlock: 70000,  main: '#424242', dark: '#212121', face: '#757575', pupils: '#000000', sparkles: true },
            'white':   { name: 'Arctic',  unlock: 80000,  main: '#bfc7d6', dark: '#8a99b4', face: '#dadee7', pupils: '#596b8b', sparkles: true},
            'green':   { name: 'Emerald', unlock: 90000,  main: '#028f1e', dark: '#027919', face: '#c8e6c9', pupils: '#01400e', sparkles: true, shine: true },
            'gold':    { name: 'Goldie',  unlock: 100000,  main: '#dcba00', dark: '#7a6700', face: '#fff9c4', pupils: '#524500', sparkles: true, shine: true },
            'diamond': { name: 'Diamond', unlock: 150000,  main: '#b9f2ff', dark: '#81d4fa', face: '#e1f5fe', pupils: '#0277bd', sparkles: true, shine: true },
            'rainbow': { name: 'Rainbow', unlock: 200000, face: '#ffffff', pupils: '#000000', isRainbow: true, sparkles: true, shine: true },
            'nanners': { name: 'Nanners', unlock: 999999, main: '#FFEB3B', dark: '#FBC02D', face: '#FFFDE7', pupils: '#795548', sparkles: true, isSpecial: true },
            'peeley':  { name: 'Peeley',  unlock: 999999, main: '#fefae7', dark: '#d4ac0d', face: '#fefae7', pupils: '#795548', sparkles: true, isSpecial: true },
            'bruiser': { name: 'Bruiser', unlock: 999999, main: '#FFC107', dark: '#795548', face: '#FFF9C4', pupils: '#795548', sparkles: true, isSpecial: true, sugarSpots: true },
            'spirit':  { name: 'Spirit',  unlock: 50000,  unlockMode: 'night', solidMain: '#212121', solidDark: '#000000', solidFace: '#424242', pupils: '#FFEB3B', glowingEyes: true, isTransparent: true, sparkles: true, glows: true, glowColor: '#FFEB3B', glowRgb: '255, 235, 59', speedMultiplier: 1.1 * speedMultiplier },
            'soul':    { name: 'Soul',    unlock: 100000, unlockMode: 'night', solidMain: '#FFFFFF', solidDark: '#E0E0E0', solidFace: '#FAFAFA', pupils: '#FFEB3B', glowingEyes: true, isTransparent: true, sparkles: true, glows: true, glowColor: '#FFEB3B', glowRgb: '255, 235, 59', speedMultiplier: 1.2 * speedMultiplier, ghostEyes: true },
            'ghoul':   { name: 'Ghoul',   unlock: 150000, unlockMode: 'night', solidMain: '#38F904', solidDark: '#04BA00', solidFace: '#7CFC00', pupils: '#FFEB3B', glowingEyes: true, glows: true, isTransparent: true, sparkles: true, glowRgb: '56, 249, 4', speedMultiplier: 1.3 * speedMultiplier },
            'checkers': { name: 'Checkers', unlock: 60, unlockMode: 'sprint_10000', main: '#BDBDBD', dark: '#616161', face: '#E0E0E0', pupils: '#D32F2F', checkeredTail: true, sparkles: true, speedMultiplier: 1.1 * speedMultiplier },
            'tako':     { name: 'Peeko', unlock: 120, unlockMode: 'sprint_20000', main: '#FAFAFA', dark: '#4E342E', face: '#4E342E', pupils: '#CC8D35', sparkles: true, speedMultiplier: 1.2 * speedMultiplier },
            'ember':    { name: 'Rafa', unlock: 180, unlockMode: 'sprint_30000', main: '#BF360C', dark: '#3E2723', face: '#212121', pupils: '#FF6F00', glowingEyes: true, sootTail: true, sparkles: true, speedMultiplier: 1.3 * speedMultiplier },
        };
        let selectedCharacterKey = 'orange';
        let unlockedCharacters = ['orange'];
        let newlyUnlockedCharacters = [];
        let characterSelectButtons = [];
        let backButtonRect = {};

        let scale = 1, offsetX = 0, offsetY = 0;

        // --- Off-screen buffer for transparent monkey rendering ---
        const monkeyBuffer = document.createElement('canvas');
        const monkeyBufferCtx = monkeyBuffer.getContext('2d');
        const bufferSize = 250; // Increased buffer size for higher quality
        monkeyBuffer.width = bufferSize;
        monkeyBuffer.height = bufferSize;

        // --- One-time High Score Migration ---
        function migrateOldScores() {
            if (localStorage.getItem(MIGRATION_FLAG_KEY)) {
                return; // Migration has already been run
            }

            console.log("Running one-time score migration check...");
            const oldScoresData = localStorage.getItem(OLD_HIGH_SCORE_KEY);

            if (oldScoresData) {
                try {
                    const oldScores = JSON.parse(oldScoresData);
                    if (Array.isArray(oldScores) && oldScores.length > 0) {
                        console.log("Found old high scores. Migrating to Classic mode.");
                        localStorage.setItem(HIGH_SCORE_KEY, oldScoresData);
                        // Optional: remove old key after successful migration.
                        // It's safer to leave it, but removing it keeps localStorage clean.
                        // localStorage.removeItem(OLD_HIGH_SCORE_KEY);
                    }
                } catch(e) {
                    console.error("Could not parse old high scores during migration.", e);
                }
            }
            
            // Set the flag so this code never runs again for this user.
            localStorage.setItem(MIGRATION_FLAG_KEY, 'true');
            console.log("Migration check complete.");
        }

        // --- Audio Management ---
        function playSound(sound) {
            if (!isMuted) {
                sound.currentTime = 0;
                sound.play().catch(e => console.warn('Sound playback failed', e));
            }
        }
        
        function loadMuteState() {
            isMuted = localStorage.getItem(MUTE_KEY) === 'true';
        }

        function saveMuteState() {
            localStorage.setItem(MUTE_KEY, isMuted);
        }

        function ensureMusicIsPlaying() {
            if (isMuted) {
                bgMusic.pause();
                return;
            }
            if (!musicStarted) {
                const promise = bgMusic.play();
                if (promise !== undefined) {
                    promise.then(_ => { musicStarted = true; }).catch(error => {
                        console.warn('Music could not be started yet (requires user gesture):', error);
                    });
                }
            } else if (bgMusic.paused) {
                bgMusic.play().catch(e => console.warn('Resuming music failed.', e));
            }
        }
        
        function toggleMute() {
            isMuted = !isMuted;
            saveMuteState();
            ensureMusicIsPlaying();
        }

        document.addEventListener('click', () => {
            if (!musicStarted) ensureMusicIsPlaying();
        }, { once: true });


        function resize() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            if (isTouchDevice) {
                GAME_HEIGHT = BASE_GAME_HEIGHT;
                GAME_WIDTH = windowWidth / windowHeight * GAME_HEIGHT;
                canvas.width = GAME_WIDTH;
                canvas.height = GAME_HEIGHT;
                canvas.style.width = '100vw';
                canvas.style.height = '100vh';
                offsetX = 0;
                offsetY = 0;
                scale = 1;

            } else {
                GAME_WIDTH = BASE_GAME_WIDTH;
                GAME_HEIGHT = BASE_GAME_HEIGHT;
                scale = Math.min(windowWidth / GAME_WIDTH, windowHeight / GAME_HEIGHT);
                canvas.style.width = `${GAME_WIDTH * scale}px`;
                canvas.style.height = `${GAME_HEIGHT * scale}px`;
                canvas.width = GAME_WIDTH;
                canvas.height = GAME_HEIGHT;
                const rect = canvas.getBoundingClientRect();
                offsetX = rect.left;
                offsetY = rect.top;
            }
            MUTE_BUTTON_RECT.x = GAME_WIDTH - 70;
            if (skySystem) skySystem.init(true);
        }
        window.addEventListener('resize', resize);
        
        function screenToCanvasCoords(screenX, screenY) {
            if (isTouchDevice) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: (screenX - rect.left) * (GAME_WIDTH / rect.width),
                    y: (screenY - rect.top) * (GAME_HEIGHT / rect.height)
                };
            } else {
                return {
                    x: (screenX - offsetX) / scale,
                    y: (screenY - offsetY) / scale
                };
            }
        }

        let lastTime = 0, gameState = 'start', scrollY = 0, score = 0, gameTime = 0, animationFrameId;
        let selectedGameMode = 'classic';
        let sprintTargetHeight = 0;
        let finishLine = { y: 0, triggered: false };
        let sprintBananasCollectedConsecutively = 0;
        let sprintBananaCooldownTimer = 0;
        let isNewHighScore = false;
        let finalTime = 0;
        let ingameInstructions = { active: false, opacity: 1.0, hasMoved: false };
        let specialAbilityNotice = { active: false, text: "", opacity: 0, timer: 0 };
        let consecutiveBananasCollected = 0;
        const menuButtons = { start: null, classic: null, night: null, sprint: null, back: null, sprint10: null, sprint20: null, sprint30: null, gameOverContinue: null, gameOverBack: null };

        const keys = {a:0,d:0,ArrowLeft:0,ArrowRight:0};
        window.addEventListener('keydown', e=>{if(keys.hasOwnProperty(e.key)) { keys[e.key]=1; if(gameState === 'playing' && !ingameInstructions.hasMoved) ingameInstructions.hasMoved = true; } if((gameState==='start'||gameState==='gameOver'||gameState==='modeSelect'||gameState==='sprintSelect')&&(e.key===' '||e.key==='Enter')) handleEnterPress();});
        window.addEventListener('keyup', e=>{if(keys.hasOwnProperty(e.key))keys[e.key]=0;});
        
        function handleEnterPress() {
            if (gameState === 'start') {
                gameState = 'modeSelect';
            } else if (gameState === 'gameOver') {
                initializeLevel();
            } else if (gameState === 'modeSelect') {
                selectModeAndProceed('classic'); // Default to classic
            } else if (gameState === 'sprintSelect') {
                selectSprintAndProceed(10000); // Default to 10k
            }
        }

        let activeTouches = {};

        function updateMovementKeysFromTouches() {
            let goLeft = false;
            let goRight = false;
            for (const id in activeTouches) {
                if (activeTouches[id] === 'left') goLeft = true;
                if (activeTouches[id] === 'right') goRight = true;
            }
            if (goRight) {
                keys.d = 1; keys.ArrowRight = 1;
                keys.a = 0; keys.ArrowLeft = 0;
            } else if (goLeft) {
                keys.a = 1; keys.ArrowLeft = 1;
                keys.d = 0; keys.ArrowRight = 0;
            } else {
                keys.a = 0; keys.d = 0; keys.ArrowLeft = 0; keys.ArrowRight = 0;
            }
        }

        function handleInteraction(screenX, screenY) {
            const { x, y } = screenToCanvasCoords(screenX, screenY);
            
            if (['start', 'modeSelect', 'sprintSelect', 'characterSelect', 'gameOver'].includes(gameState)) {
                if (x > MUTE_BUTTON_RECT.x && x < MUTE_BUTTON_RECT.x + MUTE_BUTTON_RECT.w && y > MUTE_BUTTON_RECT.y && y < MUTE_BUTTON_RECT.y + MUTE_BUTTON_RECT.h) {
                    toggleMute();
                    return;
                }
            }

            if (gameState === 'start') {
                if (menuButtons.start && x > menuButtons.start.x && x < menuButtons.start.x + menuButtons.start.w && y > menuButtons.start.y && y < menuButtons.start.y + menuButtons.start.h) {
                    gameState = 'modeSelect';
                }
            } else if (gameState === 'modeSelect') {
                if(menuButtons.classic && x > menuButtons.classic.x && x < menuButtons.classic.x + menuButtons.classic.w && y > menuButtons.classic.y && y < menuButtons.classic.y + menuButtons.classic.h) selectModeAndProceed('classic');
                if(menuButtons.night && x > menuButtons.night.x && x < menuButtons.night.x + menuButtons.night.w && y > menuButtons.night.y && y < menuButtons.night.y + menuButtons.night.h) selectModeAndProceed('night');
                if(menuButtons.sprint && x > menuButtons.sprint.x && x < menuButtons.sprint.x + menuButtons.sprint.w && y > menuButtons.sprint.y && y < menuButtons.sprint.y + menuButtons.sprint.h) gameState = 'sprintSelect';
                if(menuButtons.back && x > menuButtons.back.x && x < menuButtons.back.x + menuButtons.back.w && y > menuButtons.back.y && y < menuButtons.back.y + menuButtons.back.h) init();

            } else if (gameState === 'sprintSelect') {
                if(menuButtons.sprint10 && x > menuButtons.sprint10.x && x < menuButtons.sprint10.x + menuButtons.sprint10.w && y > menuButtons.sprint10.y && y < menuButtons.sprint10.y + menuButtons.sprint10.h) selectSprintAndProceed(10000);
                if(menuButtons.sprint20 && x > menuButtons.sprint20.x && x < menuButtons.sprint20.x + menuButtons.sprint20.w && y > menuButtons.sprint20.y && y < menuButtons.sprint20.y + menuButtons.sprint20.h) selectSprintAndProceed(20000);
                if(menuButtons.sprint30 && x > menuButtons.sprint30.x && x < menuButtons.sprint30.x + menuButtons.sprint30.w && y > menuButtons.sprint30.y && y < menuButtons.sprint30.y + menuButtons.sprint30.h) selectSprintAndProceed(30000);
                if(menuButtons.back && x > menuButtons.back.x && x < menuButtons.back.x + menuButtons.back.w && y > menuButtons.back.y && y < menuButtons.back.y + menuButtons.back.h) gameState = 'modeSelect';

            } else if (gameState === 'characterSelect') {
                if (backButtonRect && x > backButtonRect.x && x < backButtonRect.x + backButtonRect.w && y > backButtonRect.y && y < backButtonRect.y + backButtonRect.h) {
                    gameState = (selectedGameMode === 'sprint') ? 'sprintSelect' : 'modeSelect'; // Go back to correct menu
                    return;
                }
                for(const btn of characterSelectButtons) {
                    if (x > btn.x && x < btn.x + btn.w && y > btn.y && y < btn.y + btn.h) {
                        selectedCharacterKey = btn.key;
                        initializeLevel();
                    }
                }
            } else if (gameState === 'gameOver') {
                if (menuButtons.gameOverContinue && x > menuButtons.gameOverContinue.x && x < menuButtons.gameOverContinue.x + menuButtons.gameOverContinue.w && y > menuButtons.gameOverContinue.y && y < menuButtons.gameOverContinue.y + menuButtons.gameOverContinue.h) {
                    initializeLevel();
                    return;
                }
                if (menuButtons.gameOverBack && x > menuButtons.gameOverBack.x && x < menuButtons.gameOverBack.x + menuButtons.gameOverBack.w && y > menuButtons.gameOverBack.y && y < menuButtons.gameOverBack.y + menuButtons.gameOverBack.h) {
                    if (selectedGameMode === 'sprint') {
                        gameState = 'sprintSelect';
                    } else { 
                        checkUnlocks();
                        gameState = 'characterSelect';
                    }
                    return; 
                }
            }
        }
        
        const handleTouchStart = (e) => {
             e.preventDefault();
             const changed = e.changedTouches;
             if (['start', 'modeSelect', 'sprintSelect', 'characterSelect', 'gameOver'].includes(gameState)) {
                 handleInteraction(changed[0].clientX, changed[0].clientY);
                 return;
             }
             if (ingameInstructions.active && !ingameInstructions.hasMoved) { ingameInstructions.hasMoved = true; }
             for (let i = 0; i < changed.length; i++) {
                 const touch = changed[i];
                 activeTouches[touch.identifier] = touch.clientX < window.innerWidth / 2 ? 'left' : 'right';
             }
             updateMovementKeysFromTouches();
        };
        const handleTouchMove = (e) => {
            e.preventDefault();
            if (gameState !== 'playing') return;
            const changed = e.changedTouches;
            for (let i = 0; i < changed.length; i++) {
                const touch = changed[i];
                if (activeTouches.hasOwnProperty(touch.identifier)) {
                    activeTouches[touch.identifier] = touch.clientX < window.innerWidth / 2 ? 'left' : 'right';
                }
            }
            updateMovementKeysFromTouches();
        };
        const handleTouchEnd = (e) => {
            e.preventDefault();
            const changed = e.changedTouches;
            for (let i = 0; i < changed.length; i++) {
                const touch = changed[i];
                delete activeTouches[touch.identifier];
            }
            updateMovementKeysFromTouches();
        };

        canvas.addEventListener('click', (e) => { if (!isTouchDevice) handleInteraction(e.clientX, e.clientY); });
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });

        const particles = [], vinePool = [], bananaPool = [], bananaConfetti = [];

        const skySystem = {
            stars: [], clouds: [], shootingStars: [],
            generateCloudPuffs() {
                const puffs = []; const puffCount = Math.floor(Math.random() * 4) + 5; const baseWidth = (Math.random() * 100 + 130);
                for (let i = 0; i < puffCount; i++) { puffs.push({ dx: (Math.random() - 0.5) * baseWidth * 0.8, dy: (Math.random() - 0.5) * 33, r: (Math.random() * 0.4 + 0.6) * (baseWidth / (puffCount/2.5)) }); }
                return { puffs, baseWidth };
            },
            init(isResize = false) {
                if(isResize) { this.stars = []; this.clouds = []; }
                if(this.stars.length === 0) {
                    for(let i=0; i<300; i++) this.stars.push({x:Math.random()*GAME_WIDTH,y:Math.random()*GAME_HEIGHT,z:Math.random()*0.5+0.1,b:Math.random()*0.8+0.2});
                }
                if(this.clouds.length === 0) {
                    for(let i=0; i<20; i++) {
                        const cloudData = this.generateCloudPuffs();
                        this.clouds.push({x: Math.random()*GAME_WIDTH, y: Math.random()*GAME_HEIGHT, z: Math.random()*0.5+0.2, w: cloudData.baseWidth, puffs: cloudData.puffs});
                    }
                }
            },
            update(dt, nightlight) {
                this.clouds.forEach(c => { c.x += 20 * c.z * dt; if(c.x - c.w > GAME_WIDTH) c.x = -c.w * 2; });
                if (nightlight > 0.6 && Math.random() < 0.004) { this.shootingStars.push({ x: Math.random() * GAME_WIDTH * 1.2, y: Math.random() * GAME_HEIGHT * 0.4, len: (Math.random() * 200 + 160), speed: (Math.random() * 530 + 660), life: 1.2, angle: Math.PI * 0.35 + Math.random() * 0.1 }); }
                this.shootingStars.forEach((s, i) => { s.x -= s.speed * dt; s.y += s.speed * Math.tan(s.angle) * dt; s.life -= dt; if (s.life <= 0) this.shootingStars.splice(i, 1); });
            },
            draw(gameClock) {
                const daylight = 0.5 - Math.cos(gameClock * 2 * Math.PI) * 0.5; const nightlight = 1 - daylight;
                const topH=205+35*daylight, topS=50+40*daylight, topL=10+55*daylight; const botH=220+20*daylight, botS=50+20*daylight, botL=25+45*daylight;
                const grad=ctx.createLinearGradient(0,0,0,GAME_HEIGHT); grad.addColorStop(0,`hsl(${topH},${topS}%,${topL}%)`); grad.addColorStop(1,`hsl(${botH},${botS}%,${botL}%)`);
                ctx.fillStyle=grad; ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT);
                ctx.globalAlpha = nightlight * 0.9;
                this.stars.forEach(s=>{ctx.fillStyle=`rgba(255,255,255,${s.b*(0.5+Math.sin(Date.now()*s.z/1000)*0.5)})`;ctx.beginPath();ctx.arc(s.x,(s.y-scrollY*s.z)%GAME_HEIGHT,s.z*2,0,2*Math.PI);ctx.fill();});
                this.shootingStars.forEach(s => { const tailX = s.x + s.len; const tailY = s.y - s.len * Math.tan(s.angle); const starGrad = ctx.createLinearGradient(s.x, s.y, tailX, tailY); starGrad.addColorStop(0, `rgba(255, 255, 224, ${s.life})`); starGrad.addColorStop(1, 'rgba(255, 255, 224, 0)'); ctx.strokeStyle = starGrad; ctx.lineWidth = 3.3; ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(tailX, tailY); ctx.stroke(); });
                ctx.globalAlpha = daylight * 0.9;
                this.clouds.forEach(c => this.drawFluffyCloud(c));
                ctx.globalAlpha = 1;
            },
            drawFluffyCloud(c) {
                const parallaxY = (c.y - scrollY * c.z); const screenHeightWithBuffer = GAME_HEIGHT + c.w * 2; const wrappedY = (parallaxY % screenHeightWithBuffer + screenHeightWithBuffer) % screenHeightWithBuffer - c.w;
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 * c.z})`; ctx.beginPath();
                c.puffs.forEach(p => { ctx.moveTo(c.x + p.dx, wrappedY + p.dy); ctx.arc(c.x + p.dx, wrappedY + p.dy, p.r, 0, Math.PI * 2); });
                ctx.fill();
            }
        };
        
        const monkey = {
            x:0,y:0,vx:0,vy:0,
            width: 40 * scaleFactor,
            height: 40 * scaleFactor,
            squash:1,onGround:false, headAngle:0,
            leftArmAngle: 0, rightArmAngle: 0, attachedHearts: [], heartEyesTimer: 0,
            attachedBananas: [], bananaEyesTimer: 0,
            isBlinking: false, blinkTimer: 2 + Math.random() * 4, blinkDuration: 0,
            isScared: false,
            boostTimer: 0,

            update(dt) {
                if (this.boostTimer > 0) {
                    this.boostTimer -= dt;
                }
                const char = CHARACTERS[selectedCharacterKey];
                
                let speedMod = 1.0;
                if (char.speedMultiplier) {
                    speedMod = char.speedMultiplier; 
                }

                const baseAcceleration = this.boostTimer > 0 ? BOOSTED_ACCELERATION : MONKEY_ACCELERATION;
                const currentAcceleration = baseAcceleration;
                const move=(keys.ArrowRight||keys.d)-(keys.ArrowLeft||keys.a); this.vx+=move*currentAcceleration*dt;
                this.vx*=FRICTION; this.x+=this.vx*dt; 
                let currentGravity = GRAVITY;
                if (this.boostTimer > 0) {
                    currentGravity -= BOOST_UP_FORCE;
                }
                this.vy+=currentGravity*dt;
                this.y+=this.vy*dt;
                if(this.x>GAME_WIDTH)this.x=-this.width;if(this.x+this.width<0)this.x=GAME_WIDTH;
                if (this.vy > JUMP_STRENGTH * 0.4) this.isScared = true;
                
                let targetRightArmAngle, targetLeftArmAngle;
                if (this.vy < 0) {
                    const upRatio = Math.min(1, Math.abs(this.vy / (JUMP_STRENGTH * 0.9)));
                    const UP_V_ANGLE = 2.7, T_POSE_ANGLE = Math.PI / 2;
                    targetRightArmAngle = -T_POSE_ANGLE - (UP_V_ANGLE - T_POSE_ANGLE) * upRatio;
                    targetLeftArmAngle =  T_POSE_ANGLE + (UP_V_ANGLE - T_POSE_ANGLE) * upRatio;
                } else {
                    targetRightArmAngle = -Math.PI / 2; targetLeftArmAngle = Math.PI / 2;
                }
                const lerpSpeed = 10;
                this.rightArmAngle += (targetRightArmAngle - this.rightArmAngle) * lerpSpeed * dt;
                this.leftArmAngle += (targetLeftArmAngle - this.leftArmAngle) * lerpSpeed * dt;

                const currentMaxSpeed = MONKEY_MAX_SPEED;
                this.headAngle=(this.headAngle*0.9)+(this.vx/currentMaxSpeed*0.8*0.1);
                this.squash=this.onGround?(this.squash*0.8+1.2*0.2):(this.squash*0.8+1.0*0.2); this.onGround=false;
                
                this.blinkTimer -= dt;
                if (this.blinkTimer <= 0 && !this.isBlinking) { this.isBlinking = true; this.blinkDuration = 0.15; }
                if (this.isBlinking) { this.blinkDuration -= dt; if (this.blinkDuration <= 0) { this.isBlinking = false; this.blinkTimer = 2 + Math.random() * 4; } }
                
                this.attachedHearts.forEach((h, i) => { h.life -= dt; if (h.life <= 0) this.attachedHearts.splice(i, 1); });
                if (this.heartEyesTimer > 0) { this.heartEyesTimer -= dt; }
                this.attachedBananas.forEach((b, i) => { b.life -= dt; if (b.life <= 0) this.attachedBananas.splice(i, 1); });
                if (this.bananaEyesTimer > 0) { this.bananaEyesTimer -= dt; }

                const isBoosted = selectedGameMode === 'sprint' && this.boostTimer > 0;
                if ((char.sparkles && Math.random() < 0.3) || isBoosted) {
                    let color;
                    if (char.shine) {
                        color = `rgba(255, 215, 0, ${Math.random() * 0.5 + 0.5})`;
                    } else if (char.isRainbow) {
                        color = `hsl(${(gameTime * 60) % 360}, 90%, 70%)`;
                    } else {
                        color = char.isTransparent ? (char.solidMain || char.main) : char.main;
                    }

                    if (isBoosted) color = `rgba(255, 235, 59, ${Math.random() * 0.7 + 0.3})`;
                    
                    particles.push({
                        x: this.x + Math.random() * this.width, y: this.y + Math.random() * this.height,
                        vx: (Math.random() - 0.5) * 20, vy: (Math.random() - 0.5) * 20 - (isBoosted ? 50 : 0),
                        l: Math.random() * 0.5 + 0.3, type: 'monkeySparkle', color: color
                    });
                }
            },
            draw() { drawMonkeyAt(this.x, this.y - scrollY, selectedCharacterKey, this); },
            jump(){this.vy=-JUMP_STRENGTH;this.squash=0.7; playSound(jumpSound); },
            land(){ this.onGround=true; this.squash=1.4; this.isScared = false; },
            collectBanana(){
                if (selectedGameMode === 'sprint') {
                    this.boostTimer += BOOST_DURATION;
                    sprintBananasCollectedConsecutively++;
                    if (sprintBananasCollectedConsecutively >= SPRINT_BANANA_CONSECUTIVE_LIMIT) {
                        sprintBananaCooldownTimer = SPRINT_BANANA_COOLDOWN;
                        sprintBananasCollectedConsecutively = 0;
                    }
                }
                
                const char = CHARACTERS[selectedCharacterKey];
                if (char.isSpecial) {
                    this.bananaEyesTimer = 0.4; this.attachedBananas.length = 0;
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.random() * Math.PI * 2; const dist = 30 + Math.random() * 20;
                        this.attachedBananas.push({ ox: Math.cos(angle) * dist, oy: Math.sin(angle) * dist - this.height / 2, life: Math.random() * 0.5 + 0.5, maxLife: 1.0, size: (Math.random() * 10 + 10) * scaleFactor, flipped: i % 2 === 0 });
                    }
                } else {
                    this.heartEyesTimer = 0.4; this.attachedHearts.length = 0;
                    for(let i=0; i<5; i++) {
                        const angle = Math.random() * Math.PI * 2; const dist = 30 + Math.random() * 20;
                        this.attachedHearts.push({ ox: Math.cos(angle) * dist, oy: Math.sin(angle) * dist - this.height/2, life: Math.random() * 0.5 + 0.5, maxLife: 1.0, size: (Math.random() * 8 + 8) * scaleFactor, });
                    }
                    // For specific characters, add floating bananas as well as hearts.
                    if (['spirit', 'soul', 'ghoul', 'checkers', 'tako', 'ember'].includes(selectedCharacterKey)) {
                        this.attachedBananas.length = 0;
                        for (let i = 0; i < 5; i++) {
                            const angle = Math.random() * Math.PI * 2; const dist = 30 + Math.random() * 20;
                            this.attachedBananas.push({ ox: Math.cos(angle) * dist, oy: Math.sin(angle) * dist - this.height / 2, life: Math.random() * 0.5 + 0.5, maxLife: 1.0, size: (Math.random() * 10 + 10) * scaleFactor, flipped: i % 2 === 0 });
                        }
                    }
                }

                if (selectedGameMode === 'classic') {
                    consecutiveBananasCollected++;
                    const isNannersUnlocked = localStorage.getItem(NANNERS_UNLOCK_KEY) === 'true';
                    if (consecutiveBananasCollected >= 15 && !isNannersUnlocked) { localStorage.setItem(NANNERS_UNLOCK_KEY, 'true'); if (!newlyUnlockedCharacters.find(c => c.name === CHARACTERS.nanners.name)) newlyUnlockedCharacters.push(CHARACTERS.nanners); }
                    const isPeeleyUnlocked = localStorage.getItem(PEELEY_UNLOCK_KEY) === 'true';
                    if (consecutiveBananasCollected >= 30 && !isPeeleyUnlocked) { localStorage.setItem(PEELEY_UNLOCK_KEY, 'true'); if (!newlyUnlockedCharacters.find(c => c.name === CHARACTERS.peeley.name)) newlyUnlockedCharacters.push(CHARACTERS.peeley); }
                    const isBruiserUnlocked = localStorage.getItem(BRUISER_UNLOCK_KEY) === 'true';
                    if (consecutiveBananasCollected >= 50 && !isBruiserUnlocked) { localStorage.setItem(BRUISER_UNLOCK_KEY, 'true'); if (!newlyUnlockedCharacters.find(c => c.name === CHARACTERS.bruiser.name)) newlyUnlockedCharacters.push(CHARACTERS.bruiser); }
                }
            }
        };

        // --- Refactored Monkey Drawing Logic ---

        function _drawMonkeyHeadParts(targetCtx, charKey, state) {
            const char = CHARACTERS[charKey];
            const useSolidColors = !!char.isTransparent;

            let mainColor = useSolidColors ? char.solidMain : (char.isRainbow ? `hsl(${(performance.now()/20)%360},90%,60%)` : char.main);
            let faceColor = useSolidColors ? char.solidFace : char.face;
            let darkColor = useSolidColors ? char.solidDark : char.dark;

            targetCtx.fillStyle = mainColor;
            targetCtx.beginPath(); targetCtx.arc(16, -6, 10, 0, 2 * Math.PI); targetCtx.arc(-16, -6, 10, 0, 2 * Math.PI); targetCtx.fill();
            targetCtx.beginPath(); targetCtx.arc(0, 0, 22, 0, 2 * Math.PI); targetCtx.fill();
            
            if (char.sugarSpots) {
                const originalFill = targetCtx.fillStyle;
                targetCtx.fillStyle = '#6D4C41';
                let seed = char.name.length;
                const spotCount = 7;
                function pRNG() { let x = Math.sin(seed++) * 10000; return x - Math.floor(x); }
                for (let i = 0; i < spotCount; i++) {
                    const spotX = -18 + pRNG() * 36;
                    const spotY = -18 + pRNG() * 36;
                    const spotSize = pRNG() * 2 + 1.5;
                    if (Math.hypot(spotX, spotY) < 22 - spotSize) {
                       targetCtx.beginPath(); targetCtx.arc(spotX, spotY, spotSize, 0, Math.PI * 2); targetCtx.fill();
                    }
                }
                targetCtx.fillStyle = originalFill;
            }

            if (charKey === 'nanners') {
                targetCtx.strokeStyle = darkColor; targetCtx.lineWidth = 4; targetCtx.lineCap = 'round';
                targetCtx.beginPath(); targetCtx.moveTo(0, -22); targetCtx.quadraticCurveTo(5, -10, 0, -2); targetCtx.stroke();
            }
            
            targetCtx.fillStyle = faceColor; targetCtx.beginPath(); targetCtx.ellipse(0, 2, 18, 16, 0, 0, 2 * Math.PI); targetCtx.fill();
            
            drawEye.call({ ctx: targetCtx }, char, -6, -2, state);
            drawEye.call({ ctx: targetCtx }, char, 6, -2, state);
            
            let mouthColor = darkColor || '#000';
            if (charKey === 'ember') {
                mouthColor = char.main; // Rust mouth on black face
            } else if (charKey === 'tako') {
                mouthColor = '#D2B48C'; // A khaki/tan color, darker than white
            } else if (charKey === 'soul') {
                mouthColor = 'black';
            }
            targetCtx.strokeStyle = mouthColor;
            targetCtx.lineWidth = 2; targetCtx.lineCap = 'round';
            targetCtx.beginPath();
            if (state.isScared) {
                targetCtx.moveTo(-6, 9); targetCtx.quadraticCurveTo(-2, 6, 0, 9); targetCtx.quadraticCurveTo(2, 12, 6, 9);
            } else if (state.vy < -210) {
                targetCtx.ellipse(0, 8, 3, 5, 0, 0, 2 * Math.PI);
            } else {
                targetCtx.moveTo(-4, 7); targetCtx.quadraticCurveTo(0, 9, 4, 7);
            }
            targetCtx.stroke();
        }

        function drawMonkeyHead(size, charKey, verticalOffset = 0) {
            // This function assumes the main `ctx` is already translated to the center of where the head should be.
            const char = CHARACTERS[charKey];
            const dummyState = { headAngle: 0, isBlinking: false, isScared: false, heartEyesTimer: 0, bananaEyesTimer: 0, vy: 0 };
            
            if (char.isTransparent) {
                monkeyBufferCtx.clearRect(0, 0, monkeyBuffer.width, monkeyBuffer.height);
                monkeyBufferCtx.save();
                monkeyBufferCtx.translate(monkeyBuffer.width / 2, monkeyBuffer.height / 2);
                const baseSize = 40;
                monkeyBufferCtx.scale(size / baseSize, size / baseSize);
                _drawMonkeyHeadParts(monkeyBufferCtx, charKey, dummyState);
                monkeyBufferCtx.restore();
                
                ctx.save();
                ctx.globalAlpha = 0.7;
                if (char.glows) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = char.glowColor || char.solidMain;
                }
                ctx.drawImage(monkeyBuffer, -monkeyBuffer.width / 2, -monkeyBuffer.height / 2 + verticalOffset);
                ctx.restore();
            } else {
                ctx.save();
                ctx.translate(0, verticalOffset);
                const baseSize = 40;
                ctx.scale(size / baseSize, size / baseSize);
                _drawMonkeyHeadParts(ctx, charKey, dummyState);
                ctx.restore();
            }
        }
        
        function _internal_drawMonkey(ctx, centerX, centerY, charKey, state, useSolidColors = false) {
             ctx.save();
             ctx.translate(centerX, centerY);
             const char = CHARACTERS[charKey];

             if (state.boostTimer > 0 && !useSolidColors) {
                ctx.shadowBlur = 30;
                ctx.shadowColor = `rgba(255, 235, 59, ${0.5 + Math.sin(gameTime * 20) * 0.5})`;
             }
            
            const bodyW=state.width*(2-state.squash), bodyH=state.height*state.squash;
            
            let mainColor = useSolidColors ? (char.solidMain || char.main) : char.main;
            let darkColor = useSolidColors ? (char.solidDark || char.dark) : char.dark;
            let faceColor = useSolidColors ? (char.solidFace || char.face) : char.face;

            if (char.isRainbow && !useSolidColors) {
                const hue = (gameTime * 60) % 360;
                mainColor = `hsl(${hue}, 90%, 60%)`;
                darkColor = `hsl(${hue}, 70%, 30%)`;
            }

            const tailColor = (charKey === 'bruiser') ? '#6D4C41' : (charKey === 'peeley') ? '#FFC107' : ((charKey === 'tako') ? darkColor : mainColor);
            drawTail.call({ ctx }, state, tailColor);
            const legAngle=Math.sin(Date.now()/200)*0.1-state.vy/2000;
            const legColor = charKey === 'tako' ? darkColor : mainColor;
            drawLeg.call({ ctx }, -bodyW/4,bodyH/4,legAngle, legColor, state.width); 
            drawLeg.call({ ctx }, bodyW/4,bodyH/4,legAngle, legColor, state.width);
            
            if (char.shine && !useSolidColors) {
                const shineGrad = ctx.createLinearGradient(-bodyW/2, -bodyH/2, bodyW/2, bodyH/2);
                const shinePos = (Math.sin(gameTime * 4) + 1) / 2;
                const shineColor = charKey === 'diamond' ? '#e3f2fd' : 'white';
                const shineWidth = 0.1;
                shineGrad.addColorStop(Math.max(0, shinePos - shineWidth), mainColor);
                shineGrad.addColorStop(shinePos, shineColor);
                shineGrad.addColorStop(Math.min(1, shinePos + shineWidth), mainColor);
                ctx.fillStyle = shineGrad;
            } else {
                ctx.fillStyle=mainColor;
            }
            ctx.beginPath(); ctx.roundRect(-bodyW/2,-bodyH/2,bodyW,bodyH,12 * (state.width/40)); ctx.fill();
            
            if (char.sugarSpots) {
                const originalFill = ctx.fillStyle;
                ctx.fillStyle = '#6D4C41';
                let seed = char.name.length;
                const spotCount = 12;
                function pRNG() { let x = Math.sin(seed++) * 10000; return x - Math.floor(x); }
                for (let i = 0; i < spotCount; i++) {
                    const spotX = (-bodyW/2 + 5) + pRNG() * (bodyW - 10);
                    const spotY = (-bodyH/2 + 5) + pRNG() * (bodyH - 10);
                    const spotSize = (pRNG() * 2 + 1.5) * (state.width/40);
                    ctx.beginPath();
                    ctx.arc(spotX, spotY, spotSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = originalFill;
            }
            if (charKey === 'nanners' || charKey === 'bruiser') {
                ctx.strokeStyle = darkColor; ctx.lineWidth = 4 * (state.width/40); ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(0, -bodyH / 2 + 5 * (state.width/40));
                ctx.quadraticCurveTo(bodyW * 0.2, 0, 0, bodyH / 2 - 5 * (state.width/40));
                ctx.stroke();
            }

            ctx.shadowBlur = 0;

            ctx.save(); ctx.translate(0,-bodyH/2 - 12*state.squash * (state.height/40)); ctx.rotate(state.headAngle);
            const headScale = state.width / 40;
            ctx.scale(headScale, headScale);
            _drawMonkeyHeadParts(ctx, charKey, state);
            
            state.attachedHearts.forEach(h => {
                ctx.save(); ctx.globalAlpha = Math.max(0, h.life / h.maxLife);
                ctx.font = `${h.size}px sans-serif`; ctx.textAlign = 'center';
                ctx.fillText('â¤ï¸', h.ox, h.oy); ctx.restore();
            });
            state.attachedBananas.forEach(b => {
                ctx.save();
                ctx.globalAlpha = Math.max(0, b.life / b.maxLife);
                ctx.font = `${b.size}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.translate(b.ox, b.oy);
                if (b.flipped) { ctx.scale(-1, 1); }
                ctx.fillText('ðŸŒ', 0, 0);
                ctx.restore();
            });

            ctx.restore(); 
            drawSwingingArm.call({ ctx }, -bodyW / 2 + 8, -bodyH / 4, state.leftArmAngle, mainColor, state.width, charKey);
            drawSwingingArm.call({ ctx }, bodyW / 2 - 8, -bodyH / 4, state.rightArmAngle, mainColor, state.width, charKey);
            ctx.restore();
        }

        function drawMonkeyAt(x, y, charKey, state) {
            const char = CHARACTERS[charKey];
            if (char.isTransparent) {
                const monkeyCenterX = x + state.width / 2;
                const monkeyCenterY = y + state.height / 2;
                monkeyBufferCtx.clearRect(0, 0, monkeyBuffer.width, monkeyBuffer.height);
                _internal_drawMonkey(monkeyBufferCtx, monkeyBuffer.width / 2, monkeyBuffer.height / 2, charKey, state, true);
                
                ctx.save();
                ctx.globalAlpha = 0.7;
                if (char.glows) {
                    ctx.shadowBlur = 25;
                    if (char.glowRgb) {
                        ctx.shadowColor = `rgba(${char.glowRgb}, ${0.6 + Math.sin(gameTime * 5) * 0.4})`;
                    } else { // Fallback for static color if rgb is not defined
                        ctx.shadowColor = char.solidMain;
                    }
                }
                ctx.drawImage(monkeyBuffer, monkeyCenterX - monkeyBuffer.width / 2, monkeyCenterY - monkeyBuffer.height / 2);
                ctx.restore();
            } else {
                _internal_drawMonkey(ctx, x + state.width / 2, y + state.height / 2, charKey, state, false);
            }
        }

        function drawEye(char, x, y, state) {
            const ctx = this.ctx || window.ctx; // Use passed context or global
            if (char.glowingEyes) {
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = char.pupils;
            }

            if (state.heartEyesTimer > 0) {
                ctx.font = `bold ${8 * scaleFactor}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('â¤ï¸', x, y);
            } else if (state.bananaEyesTimer > 0) {
                ctx.save(); ctx.font = `bold ${10 * scaleFactor}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.translate(x, y); if (x < 0) { ctx.scale(-1, 1); } ctx.fillText('ðŸŒ', 0, 0); ctx.restore();
            } else if (char.ghostEyes) {
                // Black sclera (whites of the eyes)
                ctx.fillStyle = 'black';
                ctx.strokeStyle = '#424242';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(x, y, 5.5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();

                // Yellow pupil on top
                ctx.fillStyle = char.pupils;
                ctx.beginPath();
                ctx.arc(x + state.headAngle * 4, y, 2.8, 0, 2 * Math.PI);
                ctx.fill();
            } else if (state.isScared) {
                ctx.strokeStyle = char.dark || '#000'; ctx.lineWidth = 2; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(x - 4, y); ctx.lineTo(x + 4, y); ctx.stroke();
            } else if (state.isBlinking) {
                ctx.strokeStyle = char.dark || '#000'; ctx.lineWidth = 2; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(x - 4, y); ctx.lineTo(x + 4, y); ctx.stroke();
            } else {
                ctx.fillStyle = 'white'; ctx.strokeStyle = '#a79a95'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.arc(x, y, 5.5, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
                ctx.fillStyle = char.pupils; ctx.beginPath();
                ctx.arc(x + state.headAngle * 4, y, 2.8, 0, 2 * Math.PI); ctx.fill();
            }

            if (char.glowingEyes) {
                ctx.restore();
            }
        }
        function drawLeg(x,y,a,c, baseWidth){ const ctx = this.ctx || window.ctx; ctx.save();ctx.translate(x,y);ctx.rotate(a);ctx.strokeStyle=c;ctx.lineWidth=10 * (baseWidth/40);ctx.lineCap='round';ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(0,16 * (baseWidth/40));ctx.stroke();ctx.restore();}
        
        function drawSwingingArm(x, y, angle, color, baseWidth, charKey) { const ctx = this.ctx || window.ctx;
            ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
            const armScale = baseWidth / 40;
            const handColor = (charKey === 'tako') ? CHARACTERS.tako.dark
                              : (charKey === 'ember') ? '#424242'
                              : (charKey === 'checkers') ? '#212121'
                              : color;
            ctx.lineCap = 'round'; ctx.strokeStyle = color; ctx.lineWidth = 8 * armScale;
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 20 * armScale); ctx.stroke();
            ctx.fillStyle = handColor;
            ctx.beginPath(); ctx.arc(0, 20 * armScale, 6 * armScale, 0, 2 * Math.PI); ctx.fill();
            ctx.restore();
        }

        function drawTail(state, color) { const ctx = this.ctx || window.ctx;
            const tailScale = state.width / 40;
            const bodyBottomY = state.height / 2 - (6 * tailScale); const sway = Math.sin(gameTime * 12) * (10 * tailScale); const lift = Math.max(0, -state.vy * 0.05);
            const startY = bodyBottomY - lift * 0.5;
            const p0 = { x: 0, y: startY };
            const cp1 = { x: sway, y: startY + (22 * tailScale) - lift }; const cp2 = { x: -sway, y: startY + (38 * tailScale) - lift * 0.5 };
            const end = { x: sway * 0.3, y: startY + (50 * tailScale) - lift * 0.2 };
            
            const char = CHARACTERS[selectedCharacterKey];
            
            if (char.checkeredTail) {
                const tailWidth = 6 * tailScale;
                const stripeLength = 10 * tailScale;
                
                // 1. Draw a solid black tail first.
                ctx.lineWidth = tailWidth;
                ctx.strokeStyle = '#212121'; // Solid black base
                ctx.lineCap = 'butt';
                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y);
                ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
                ctx.stroke();

                // 2. Draw dashed white stripes on top.
                ctx.setLineDash([stripeLength, stripeLength]);
                ctx.strokeStyle = '#FFFFFF'; // Dashed white stripes
                ctx.beginPath();
                ctx.moveTo(p0.x, p0.y);
                ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);
                ctx.stroke();

                // 3. Reset line dash and cap for other drawing operations.
                ctx.setLineDash([]);
                ctx.lineCap = 'round';
                return; // Exit after drawing the custom tail
            }
            
            ctx.lineCap = 'round';
            if (char.sootTail) {
                ctx.strokeStyle = '#424242'; ctx.lineWidth = 6 * tailScale;
                ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y); ctx.stroke();
            } else {
                ctx.strokeStyle = color; ctx.lineWidth = 6 * tailScale;
                ctx.beginPath(); ctx.moveTo(p0.x, p0.y); ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y); ctx.stroke();
            }
        }
        
        // --- High Score Logic ---
        function getHighScores(){try{const s=JSON.parse(localStorage.getItem(HIGH_SCORE_KEY));return Array.isArray(s)?s:[];}catch(e){return[];}}
        function saveHighScores(s){localStorage.setItem(HIGH_SCORE_KEY,JSON.stringify(s));}
        function getNightHighScores(){try{const s=JSON.parse(localStorage.getItem(NIGHT_HIGH_SCORE_KEY));return Array.isArray(s)?s:[];}catch(e){return[];}}
        function saveNightHighScores(s){localStorage.setItem(NIGHT_HIGH_SCORE_KEY,JSON.stringify(s));}
        function getSprintHighScores(distance){try{const s=JSON.parse(localStorage.getItem(SPRINT_HIGH_SCORE_KEY_PREFIX + distance));return Array.isArray(s)?s:[];}catch(e){return[];}}
        function saveSprintHighScores(s, distance){localStorage.setItem(SPRINT_HIGH_SCORE_KEY_PREFIX + distance, JSON.stringify(s));}

        function getHighestScore() { return parseInt(localStorage.getItem(UNLOCK_KEY) || '0', 10); }
        function getHighestNightScore() { return parseInt(localStorage.getItem(NIGHT_HIGHEST_SCORE_KEY) || '0', 10); }

        function checkUnlocks() {
            const highestScore = getHighestScore();
            const highestNightScore = getHighestNightScore();
            unlockedCharacters = ['orange'];
            for (const key in CHARACTERS) {
                const char = CHARACTERS[key];
                if (key === 'orange') continue;
        
                if (char.unlockMode === 'night') {
                    if (highestNightScore >= char.unlock) {
                         if (!unlockedCharacters.includes(key)) unlockedCharacters.push(key);
                    }
                } else if (!char.isSpecial && !char.unlockMode) { // Classic unlocks
                     if (highestScore >= char.unlock) {
                        if (!unlockedCharacters.includes(key)) unlockedCharacters.push(key);
                    }
                }
            }
            if (localStorage.getItem(NANNERS_UNLOCK_KEY) === 'true') if (!unlockedCharacters.includes('nanners')) unlockedCharacters.push('nanners');
            if (localStorage.getItem(PEELEY_UNLOCK_KEY) === 'true') if (!unlockedCharacters.includes('peeley')) unlockedCharacters.push('peeley');
            if (localStorage.getItem(BRUISER_UNLOCK_KEY) === 'true') if (!unlockedCharacters.includes('bruiser')) unlockedCharacters.push('bruiser');
            if (localStorage.getItem(CHECKERS_UNLOCK_KEY) === 'true') if (!unlockedCharacters.includes('checkers')) unlockedCharacters.push('checkers');
            if (localStorage.getItem(TAKO_UNLOCK_KEY) === 'true') if (!unlockedCharacters.includes('tako')) unlockedCharacters.push('tako');
            if (localStorage.getItem(EMBER_UNLOCK_KEY) === 'true') if (!unlockedCharacters.includes('ember')) unlockedCharacters.push('ember');
            
            const normalChars = unlockedCharacters.filter(key => !CHARACTERS[key].isSpecial && !CHARACTERS[key].unlockMode && !CHARACTERS[key].unlockMode?.startsWith('sprint'));
            const specialDisplayOrder = ['nanners', 'peeley', 'bruiser', 'spirit', 'soul', 'ghoul', 'checkers', 'tako', 'ember'];
            const specialAndNightChars = unlockedCharacters.filter(key => specialDisplayOrder.includes(key));
            
            normalChars.sort((aKey, bKey) => CHARACTERS[aKey].unlock - CHARACTERS[bKey].unlock);
            specialAndNightChars.sort((a, b) => specialDisplayOrder.indexOf(a) - specialDisplayOrder.indexOf(b));
            
            unlockedCharacters = [...normalChars, ...specialAndNightChars];
        }

        // Handles score and unlocks for Classic mode
        function updateScores(newScore) {
            if(newScore <= 0) return { isNewHighScore: false, newUnlocks: [] };
            let newUnlocks = [];
            const oldHighest = getHighestScore();
            if (newScore > oldHighest) {
                localStorage.setItem(UNLOCK_KEY, Math.floor(newScore));
                for (const key in CHARACTERS) {
                    const char = CHARACTERS[key];
                    if (!char.isSpecial && !char.unlockMode && newScore >= char.unlock && oldHighest < char.unlock) {
                        newUnlocks.push(char);
                    }
                }
            }
            const scores = getHighScores(); const lowest = scores.length < 5 ? 0 : scores[scores.length - 1]; let isNewHighScore = false;
            if (newScore > lowest) {
                scores.push(Math.floor(newScore)); scores.sort((a,b)=>b-a);
                saveHighScores(scores.slice(0,5)); isNewHighScore = true;
            }
            return { isNewHighScore, newUnlocks };
        }
        
        // Handles score for Moonlight Climb mode (with unlocks)
        function updateNightScores(newScore) {
            if (newScore <= 0) return { isNewHighScore: false, newUnlocks: [] };
            let newUnlocks = [];
            const oldHighest = getHighestNightScore();
            if (newScore > oldHighest) {
                localStorage.setItem(NIGHT_HIGHEST_SCORE_KEY, Math.floor(newScore));
                for (const key in CHARACTERS) {
                    const char = CHARACTERS[key];
                    if (char.unlockMode === 'night' && newScore >= char.unlock && oldHighest < char.unlock) {
                        newUnlocks.push(char);
                    }
                }
            }

            const scores = getNightHighScores();
            const lowest = scores.length < 5 ? 0 : scores[scores.length - 1];
            let isNewHighScore = false;
            if (newScore > lowest) {
                scores.push(Math.floor(newScore));
                scores.sort((a,b) => b-a);
                saveNightHighScores(scores.slice(0,5));
                isNewHighScore = true;
            }
            return { isNewHighScore, newUnlocks };
        }

        // Handles time-based scores for Sprint mode (no unlocks)
        function updateSprintScores(newTime, distance) {
            const scores = getSprintHighScores(distance);
            let isNewHighScore = false;
            if (scores.length < 5 || newTime < scores[scores.length - 1]) {
                scores.push(newTime); scores.sort((a,b) => a-b);
                saveSprintHighScores(scores.slice(0,5), distance); isNewHighScore = true;
            }
            return { isNewHighScore };
        }
        
        function spawnBananaConfetti(){bananaConfetti.length=0;for(let i=0;i<60;i++)bananaConfetti.push({x:Math.random()*GAME_WIDTH,y:-Math.random()*GAME_HEIGHT,vx:(Math.random()-.5)*73,vy:Math.random()*106+40,a:Math.random()*Math.PI*2,r:(Math.random()-.5)*5,s:(Math.random()*13+13)*scaleFactor});}
        function updateConfetti(dt){const g=146;bananaConfetti.forEach(p=>{p.vy+=g*dt;p.x+=p.vx*dt;p.y+=p.vy*dt;p.a+=p.r*dt;});}
        function drawBananaConfetti(){bananaConfetti.forEach(p=>{ctx.save();ctx.translate(p.x,p.y);ctx.rotate(p.a);ctx.font=`${p.s}px sans-serif`;ctx.textAlign='center';ctx.fillText('ðŸŒ',0,0);ctx.restore();});}
        
        function drawHighScores(x, y) {
            const scores = getHighScores(); if (scores.length === 0) return;
            ctx.textAlign = 'center'; ctx.font = `bold ${36 * scaleFactor}px sans-serif`;
            ctx.fillStyle = 'white'; ctx.fillText('High Scores (Classic)', x, y);
            ctx.font = `${30 * scaleFactor}px sans-serif`;
            scores.forEach((s, i) => {
                const scoreY = y + (i + 1) * 45 * scaleFactor;
                const medalText = MEDAL_EMOJIS[i] ? `${MEDAL_EMOJIS[i]} ` : `${i + 1}. `;
                ctx.fillStyle = MEDAL_COLORS[i] || 'white'; ctx.fillText(`${medalText}${s}`, x, scoreY);
            });
            ctx.fillStyle = 'white';
        }

        function drawNightHighScores(x, y) {
            const scores = getNightHighScores(); if (scores.length === 0) return;
            ctx.textAlign = 'center'; ctx.font = `bold ${36 * scaleFactor}px sans-serif`;
            ctx.fillStyle = 'white'; ctx.fillText('High Scores (Moonlight Climb)', x, y);
            ctx.font = `${30 * scaleFactor}px sans-serif`;
            scores.forEach((s, i) => {
                const scoreY = y + (i + 1) * 45 * scaleFactor;
                const medalText = MEDAL_EMOJIS[i] ? `${MEDAL_EMOJIS[i]} ` : `${i + 1}. `;
                ctx.fillStyle = MEDAL_COLORS[i] || 'white'; ctx.fillText(`${medalText}${s}`, x, scoreY);
            });
            ctx.fillStyle = 'white';
        }

        function drawSprintHighScores(x, y, distance) {
            const scores = getSprintHighScores(distance); if (scores.length === 0) return;
            ctx.textAlign = 'center'; ctx.font = `bold ${36 * scaleFactor}px sans-serif`;
            ctx.fillStyle = 'white'; ctx.fillText(`Best Times (${distance}m)`, x, y);
            ctx.font = `${30 * scaleFactor}px sans-serif`;
            scores.forEach((s, i) => {
                const scoreY = y + (i + 1) * 45 * scaleFactor;
                const medalText = MEDAL_EMOJIS[i] ? `${MEDAL_EMOJIS[i]} ` : `${i + 1}. `;
                ctx.fillStyle = MEDAL_COLORS[i] || 'white'; ctx.fillText(`${medalText}${formatTime(s)}`, x, scoreY);
            });
            ctx.fillStyle = 'white';
        }

        function getDifficultyLevel(currentScore) { return Math.floor(currentScore / DIFFICULTY_SCORE_INTERVAL); }

        function createVine(y, prevVine, currentScore = 0) {
            const difficulty = getDifficultyLevel(currentScore);
            const widthReduction = difficulty * 9.3 * scaleFactor;
            const currentMaxWidth = Math.max(VINE_MIN_WIDTH * 0.7, VINE_MAX_WIDTH - widthReduction);
            const currentMinWidth = Math.max(VINE_MIN_WIDTH * 0.6, VINE_MIN_WIDTH - widthReduction);
            const width = currentMinWidth + Math.random() * (currentMaxWidth - currentMinWidth);
            
            const minJumps = Math.max(2, VINE_JUMPS_TO_BREAK - Math.floor(difficulty / 4.0));
            let randomBonus = 0; if (minJumps < VINE_JUMPS_TO_BREAK && Math.random() < 0.5) randomBonus = 1;
            const jumpsLeft = minJumps + randomBonus;

            let x;
            if (prevVine) {
                const prevVineCenterX = prevVine.x + prevVine.width / 2;
                const minOffset = VINE_MIN_HORIZONTAL_OFFSET * scaleFactor;
                const horizontalReach = VINE_HORIZONTAL_REACH * scaleFactor;
                const leftZone_end = prevVineCenterX - minOffset; const leftZone_start = prevVineCenterX - horizontalReach;
                const rightZone_start = prevVineCenterX + minOffset; const rightZone_end = prevVineCenterX + horizontalReach;
                const leftZone_size = Math.max(0, leftZone_end - leftZone_start); const rightZone_size = Math.max(0, rightZone_end - rightZone_start);
                const totalZone_size = leftZone_size + rightZone_size;

                let newVineCenterX;
                if (totalZone_size <= 0) { newVineCenterX = GAME_WIDTH / 2; }
                else { const rand = Math.random() * totalZone_size; if (rand < leftZone_size) { newVineCenterX = leftZone_start + rand; } else { newVineCenterX = rightZone_start + (rand - leftZone_size); } }
                x = newVineCenterX - width / 2;
                const margin = 15; x = Math.max(margin, x); x = Math.min(x, GAME_WIDTH - width - margin);
            } else { x = Math.random() * (GAME_WIDTH - width); }
            
            const leaves=[];for(let i=0;i<width/14.5;i++){leaves.push({x:Math.random()*width,y:Math.random()*6.5-3.3,s:Math.random()*4+4,a:Math.random()*Math.PI,color:`hsl(120,50%,${25+Math.random()*20}%)`});}
            
            return {x,y,width,leaves,jumpsLeft,isFalling:false,dip:0};
        }
        
        function drawVine(vine) {
            // Do not draw vines that are above the finish line in sprint mode
            if (selectedGameMode === 'sprint' && vine.y < finishLine.y) {
                return;
            }
            vine.dip*=0.8; const drawY=vine.y-scrollY+vine.dip;
            ctx.save();
            if (vine.isFalling) { const fadeStart=GAME_HEIGHT*0.9,fadeEnd=GAME_HEIGHT*1.2;if(drawY>fadeStart){ctx.globalAlpha=1-(drawY-fadeStart)/(fadeEnd-fadeStart);} }
            ctx.translate(vine.x,drawY);
            const p1={x:0,y:10},p2={x:vine.width,y:10},cp={x:vine.width/2,y:10+vine.dip/2};
            
            ctx.strokeStyle='#3e2723';ctx.lineWidth=14*(vine.width/VINE_MAX_WIDTH);ctx.lineCap='round';ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.quadraticCurveTo(cp.x,cp.y,p2.x,p2.y);ctx.stroke();
            ctx.strokeStyle='#5d4037';ctx.lineWidth=10*(vine.width/VINE_MAX_WIDTH);ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.quadraticCurveTo(cp.x,cp.y,p2.x,p2.y);ctx.stroke();
            ctx.strokeStyle='#8d6e63';ctx.lineWidth=4*(vine.width/VINE_MAX_WIDTH);ctx.beginPath();ctx.moveTo(p1.x,p1.y-1);ctx.quadraticCurveTo(cp.x,cp.y-1,p2.x,p2.y-1);ctx.stroke();
            vine.leaves.forEach(l=>{ctx.save();ctx.translate(l.x,l.y+10);ctx.rotate(l.a);ctx.fillStyle=l.color;ctx.beginPath();ctx.ellipse(0,0,l.s,l.s/2,0,0,2*Math.PI);ctx.fill();ctx.restore();});
            
            ctx.restore();
        }

        function drawBanana(b) {
            if(b.isCollected)return; const glow=0.6+Math.sin(Date.now()/200)*0.4;
            ctx.save(); ctx.shadowBlur=20;ctx.shadowColor=`rgba(255,223,0,${glow})`;
            ctx.fillStyle='white';ctx.font=`${32 * scaleFactor}px sans-serif`;ctx.textAlign='center';
            ctx.fillText('ðŸŒ',b.x,b.y-scrollY); ctx.restore();
        }

        function drawFinishLine() {
            if (selectedGameMode !== 'sprint' || finishLine.triggered) return;
            const drawY = finishLine.y - scrollY;
            if (drawY > GAME_HEIGHT || drawY < -50) return;

            const bananaYellow = '#FFEB3B', bananaBrown = '#6D4C41', bananaWhite = '#FFFDE7';
            const segmentWidth = 60 * scaleFactor;
            const flagHeight = 35 * scaleFactor;

            ctx.save();
            ctx.shadowColor = bananaWhite;
            ctx.shadowBlur = 15;
            for(let i = 0; i < GAME_WIDTH; i += segmentWidth) {
                ctx.fillStyle = (Math.floor(i / segmentWidth) % 2 === 0) ? bananaYellow : bananaBrown;
                ctx.fillRect(i, drawY, segmentWidth, flagHeight);
            }
            ctx.strokeStyle = bananaWhite; ctx.lineWidth = 4;
            ctx.strokeRect(0, drawY, GAME_WIDTH, flagHeight);
            ctx.restore();
        }
        
        function init() {
            gameState = 'start';
            if (!animationFrameId) {
                lastTime = performance.now();
                dt = 0;
                loop(lastTime);
            }
        }
        
        function selectModeAndProceed(mode) {
            selectedGameMode = mode;
            checkUnlocks();
            if (unlockedCharacters.length > 1) {
                gameState = 'characterSelect';
            } else {
                selectedCharacterKey = 'orange';
                initializeLevel();
            }
        }

        function selectSprintAndProceed(distance) {
            selectedGameMode = 'sprint';
            sprintTargetHeight = distance;
            
            if (distance === 10000) selectedCharacterKey = 'checkers';
            else if (distance === 20000) selectedCharacterKey = 'tako';
            else if (distance === 30000) selectedCharacterKey = 'ember';
            
            initializeLevel();
        }

        function initializeLevel() {
            ensureMusicIsPlaying();
            scrollY=0;score=0;gameTime=0;finalTime=0;gameState='playing';particles.length=0; isNewHighScore=false; newlyUnlockedCharacters=[]; bananaConfetti.length=0; 
            monkey.attachedHearts.length = 0; monkey.attachedBananas.length = 0; consecutiveBananasCollected = 0; monkey.boostTimer = 0;
            monkey.x=GAME_WIDTH/2-monkey.width/2;monkey.y=GAME_HEIGHT-150;monkey.vx=0;monkey.vy=0; monkey.isScared = false;
            finishLine = { y: -sprintTargetHeight, triggered: false };
            sprintBananasCollectedConsecutively = 0;
            sprintBananaCooldownTimer = 0;
            
            ingameInstructions = { active: true, opacity: 1.0, hasMoved: false };
            specialAbilityNotice = { active: false, text: "", opacity: 0, timer: 0 }; 

            const char = CHARACTERS[selectedCharacterKey];
            const hasPointBoost = (selectedGameMode === 'classic' || selectedGameMode === 'night') && SPECIAL_BANANA_POINTS.hasOwnProperty(selectedCharacterKey);
            
            let hasSpeedBoost = false;
            if (char.speedMultiplier && char.speedMultiplier > 1.0) {
                 hasSpeedBoost = true;
            }


            let noticeText = "";
            if (hasPointBoost && hasSpeedBoost) {
                const points = SPECIAL_BANANA_POINTS[selectedCharacterKey];
                const speedPercent = Math.round((char.speedMultiplier / speedMultiplier - 1) * 100);
                noticeText = `${char.name} gets ${points}pts/banana & a ${speedPercent}% speed boost!`;
            } else if (hasPointBoost) {
                const points = SPECIAL_BANANA_POINTS[selectedCharacterKey];
                noticeText = `${char.name} gets ${points} points per banana!`;
            } else if (hasSpeedBoost) {
                const speedPercent = Math.round((char.speedMultiplier / speedMultiplier - 1) * 100);
                noticeText = `${char.name} has a ${speedPercent}% speed boost!`;
            }

            if (noticeText) {
                specialAbilityNotice = { active: true, text: noticeText, opacity: 1.0, timer: 4.0 };
            }

            // --- Fair Start Vine Generation ---
            vinePool.length=0;bananaPool.length=0;
            let lastVine = null;

            const firstVine = createVine(monkey.y + monkey.height + 10, null, 0);
            firstVine.x = monkey.x + monkey.width / 2 - firstVine.width / 2;
            vinePool.push(firstVine);
            lastVine = firstVine;

            const secondVine = createVine(firstVine.y - VINE_VERTICAL_SPACING, firstVine, 0);
            const firstVineCenterX = firstVine.x + firstVine.width / 2;
            const offset = 100 * scaleFactor;
            const direction = Math.random() < 0.5 ? -1 : 1;
            let newVineCenterX = firstVineCenterX + (offset * direction);
            let newX = newVineCenterX - secondVine.width / 2;
            const margin = 15;
            secondVine.x = Math.max(margin, Math.min(newX, GAME_WIDTH - secondVine.width - margin));
            vinePool.push(secondVine);
            lastVine = secondVine;

            for (let i = 2; i < VINE_COUNT; i++) {
                const v = createVine(lastVine.y - VINE_VERTICAL_SPACING, lastVine, 0);
                vinePool.push(v);
                lastVine = v;
            }
        }

        let dt = 0;
        function update() {
            const initialGameState = gameState;
            if (initialGameState === 'playing') {
                gameTime += dt;
                monkey.update(dt);
                if (sprintBananaCooldownTimer > 0) {
                    sprintBananaCooldownTimer -= dt;
                }
                if (ingameInstructions.active && ingameInstructions.hasMoved) {
                    ingameInstructions.opacity -= 2.0 * dt;
                    if (ingameInstructions.opacity <= 0) ingameInstructions.active = false;
                }
                if (specialAbilityNotice.active) {
                    specialAbilityNotice.timer -= dt;
                    if (specialAbilityNotice.timer <= 1.0) specialAbilityNotice.opacity = Math.max(0, specialAbilityNotice.timer);
                    if (specialAbilityNotice.timer <= 0) specialAbilityNotice.active = false;
                }
            }
            else if (['start', 'modeSelect', 'sprintSelect', 'characterSelect'].includes(initialGameState)) { 
                gameTime += dt; // Keep animations running on menus
                skySystem.update(dt, 0.5); 
                return; 
            }
            
            const gameClock = (selectedGameMode === 'night') ? 0.8 : (scrollY / DAY_NIGHT_DISTANCE) % 1.0;
            const nightlight = 1 - (0.5 - Math.cos(gameClock * 2 * Math.PI) * 0.5);
            skySystem.update(dt, nightlight);

            if (monkey.vy > 0) {
                for (const v of vinePool) {
                    if (selectedGameMode === 'sprint' && v.y < finishLine.y) continue;
                    if (!v.isFalling && monkey.x + monkey.width > v.x && monkey.x < v.x + v.width && monkey.y + monkey.height + monkey.vy * dt > v.y && monkey.y + monkey.height <= v.y + 20) {
                        monkey.y = v.y - monkey.height;
                        monkey.jump();
                        monkey.land();
                        v.dip = 15;
                        if (gameTime > VINE_FALL_TRIGGER_TIME) {
                            v.jumpsLeft--;
                            if (v.jumpsLeft <= 0) {
                                v.isFalling = true;
                                for (let i = 0; i < 5; i++) particles.push({ x: v.x + Math.random() * v.width, y: v.y, vx: (Math.random() - 0.5) * 40, vy: Math.random() * 40, l: 2, type: 'leaf' });
                            }
                        }
                        break; 
                    }
                }
            }
            
            for(const b of bananaPool){if(!b.isCollected&&Math.hypot(monkey.x+monkey.width/2-b.x,monkey.y+monkey.height/2-b.y)<50){
                b.isCollected=true;
                if (selectedGameMode === 'classic' || selectedGameMode === 'night') {
                    let pointsToAdd = SPECIAL_BANANA_POINTS[selectedCharacterKey] || BANANA_POINTS;
                    score += pointsToAdd;
                }
                monkey.collectBanana();
                playSound(sparkleSound);
                for(let i=0;i<15;i++)particles.push({x:b.x,y:b.y,vx:(Math.random()-0.5)*185,vy:(Math.random()-0.5)*185,l:1,type:'sparkle'});}}
            
            const scrollThr=GAME_HEIGHT*0.4;if(monkey.y-scrollY<scrollThr){const s=(monkey.y-scrollY)-scrollThr;scrollY+=s;if (selectedGameMode !== 'sprint') score+=Math.floor(-s);} else if (selectedGameMode === 'sprint') { score = Math.max(score, Math.floor(-monkey.y)); }
            particles.forEach((p,i)=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.l-=dt;if(p.l<=0)particles.splice(i,1);});
            
            vinePool.forEach((v, i) => {
                if (v.isFalling) { v.y += VINE_FALL_SPEED * dt; }
                if (v.y -scrollY > GAME_HEIGHT + 40) {
                    if (selectedGameMode === 'sprint' && -v.y > sprintTargetHeight) {
                        return;
                    }
                    let highestVine = null; let highestY = Infinity;
                    for (const otherVine of vinePool) { if (otherVine.y < highestY) { highestY = otherVine.y; highestVine = otherVine; } }
                    const currentProgress = (selectedGameMode === 'sprint') ? -highestY : score;
                    const difficulty = getDifficultyLevel(currentProgress), spacingIncrease = difficulty * 5.3, newSpacing = Math.min(145, VINE_VERTICAL_SPACING + spacingIncrease);
                    Object.assign(v, createVine(highestY - newSpacing, highestVine, currentProgress));
                    
                    const bananaChance = selectedGameMode === 'sprint' ? SPRINT_BANANA_SPAWN_CHANCE : BANANA_SPAWN_CHANCE;
                    const canSpawnBanana = selectedGameMode !== 'sprint' || (sprintBananaCooldownTimer <= 0 && -v.y < sprintTargetHeight - 500);
                    if (currentProgress > 1000 && Math.random() < bananaChance && canSpawnBanana) {
                         bananaPool.push({x: v.x + v.width/2, y: v.y - 50, isCollected: false});
                    }
                }
            });

            for (let i = bananaPool.length - 1; i >= 0; i--) {
                const b = bananaPool[i];
                if (b.y - scrollY > GAME_HEIGHT + 40) {
                    if (!b.isCollected && selectedGameMode !== 'sprint') consecutiveBananasCollected = 0;
                    bananaPool.splice(i, 1);
                }
            }
            
            const isFallingOffScreen = monkey.y - scrollY > GAME_HEIGHT;
            const isSprintComplete = selectedGameMode === 'sprint' && !finishLine.triggered && monkey.y <= finishLine.y;

            if ((isFallingOffScreen || isSprintComplete) && gameState === 'playing') {
                finalTime = gameTime;
                gameState='gameOver';
                
                if (isSprintComplete) {
                    finishLine.triggered = true;
                    const scoreResult = updateSprintScores(finalTime, sprintTargetHeight);
                    isNewHighScore = scoreResult.isNewHighScore;
                    if(isNewHighScore) spawnBananaConfetti();
                    
                    const charData = CHARACTERS[selectedCharacterKey];
                    if (charData && charData.unlockMode && charData.unlockMode.startsWith('sprint_')) {
                        const requiredTime = charData.unlock;
                        if (finalTime < requiredTime) {
                            const unlockKey = `gogomonkeygo_${selectedCharacterKey}_unlocked`;
                            if (localStorage.getItem(unlockKey) !== 'true') {
                                localStorage.setItem(unlockKey, 'true');
                                if (!newlyUnlockedCharacters.find(c => c.name === charData.name)) {
                                    newlyUnlockedCharacters.push(charData);
                                }
                            }
                        }
                    }
                } else if (selectedGameMode === 'classic') {
                    const scoreResult = updateScores(score);
                    isNewHighScore = scoreResult.isNewHighScore;
                    newlyUnlockedCharacters = [...new Set([...newlyUnlockedCharacters, ...scoreResult.newUnlocks])];
                    if(isNewHighScore) spawnBananaConfetti();
                } else if (selectedGameMode === 'night') {
                    const scoreResult = updateNightScores(score);
                    isNewHighScore = scoreResult.isNewHighScore;
                    newlyUnlockedCharacters = [...new Set([...newlyUnlockedCharacters, ...scoreResult.newUnlocks])];
                    if(isNewHighScore) spawnBananaConfetti();
                }
            }
        }
        
        function drawAnimatedBeveledLine(text, x, y, size, mainFill, bevelOffset) {
            ctx.font = `bold ${size}px 'Comic Sans MS', 'Chalkduster', sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            const textMetrics = ctx.measureText(text); let currentX = x - textMetrics.width / 2;
            const highlightColor = 'rgba(255, 255, 255, 0.4)'; const shadowColor = 'rgba(0, 0, 0, 0.25)';
            for (let i = 0; i < text.length; i++) {
                const char = text[i]; const charMetrics = ctx.measureText(char); const charX = currentX + charMetrics.width / 2;
                ctx.save(); ctx.translate(charX, y); ctx.rotate((Math.sin(i * 0.8 + gameTime * 3)) * 0.1);
                ctx.fillStyle = highlightColor; ctx.fillText(char, -bevelOffset, -bevelOffset); ctx.fillStyle = shadowColor; ctx.fillText(char, bevelOffset, bevelOffset);
                ctx.strokeStyle = '#4a2d1e'; ctx.lineWidth = size / 10; ctx.lineJoin = 'round';
                ctx.strokeText(char, 0, 0); ctx.fillStyle = mainFill; ctx.fillText(char, 0, 0);
                ctx.restore(); currentX += charMetrics.width;
            }
        }

        function drawLogo() {
            const baseY = 280; const lineSpacing = 120 * scaleFactor; const size1 = 110 * scaleFactor;
            const grad1 = ctx.createLinearGradient(0, baseY - size1/2, 0, baseY + size1/2); grad1.addColorStop(0, '#f9f954'); grad1.addColorStop(1, '#e3c600');
            drawAnimatedBeveledLine('Go! Go!', GAME_WIDTH / 2, baseY, size1, grad1, 4);
            const size2 = 100 * scaleFactor; const y2 = baseY + lineSpacing;
            const grad2 = ctx.createLinearGradient(0, y2 - size2/2, 0, y2 + size2/2); grad2.addColorStop(0, CHARACTERS.orange.main); grad2.addColorStop(1, CHARACTERS.orange.dark);
            drawAnimatedBeveledLine('Monkey,', GAME_WIDTH / 2, y2, size2, grad2, 3);
            const y3 = baseY + lineSpacing * 2; drawAnimatedBeveledLine('Go!', GAME_WIDTH / 2, y3, size1, grad1, 4);
        }
        
        function drawMenuButton(text, x, y, w, h, description = null) {
            const bananaYellow = '#FFEB3B', bananaBrown = '#6D4C41', bananaWhite = '#FFFDE7';
            ctx.shadowColor = bananaWhite; ctx.shadowBlur = 40;
            ctx.fillStyle = bananaYellow; ctx.strokeStyle = bananaBrown; ctx.lineWidth = 5;
            ctx.beginPath(); ctx.roundRect(x, y, w, h, 20); ctx.fill(); ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.font = `bold ${36 * scaleFactor}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.strokeStyle = bananaBrown; ctx.lineWidth = 6; ctx.lineJoin = 'round'; ctx.strokeText(text, x + w/2, y + h/2 + 2);
            ctx.fillStyle = bananaWhite; ctx.fillText(text, x + w/2, y + h/2 + 2);
            ctx.shadowBlur = 0;
            if (description) {
                ctx.font = `italic ${22 * scaleFactor}px sans-serif`;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillText(description, x + w / 2, y + h + 25 * scaleFactor);
            }
        }

        function drawBackButton(x, y, w, h, text="Back") {
             const grad = ctx.createLinearGradient(x, y, x, y + h);
            grad.addColorStop(0, 'hsl(340, 80%, 55%)'); grad.addColorStop(1, 'hsl(340, 80%, 40%)');
            ctx.fillStyle = grad; ctx.strokeStyle = 'hsl(340, 90%, 90%)'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.roundRect(x, y, w, h, 20); ctx.fill(); ctx.stroke();
            ctx.fillStyle = 'white'; ctx.font = `bold ${30 * scaleFactor}px sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 6; ctx.fillText(text, x + w / 2, y + h / 2 + 2); ctx.shadowBlur = 0;
            return { x, y, w, h };
        }

        function drawMuteButton() {
            ctx.save(); ctx.globalAlpha = 0.6; ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.roundRect(MUTE_BUTTON_RECT.x, MUTE_BUTTON_RECT.y, MUTE_BUTTON_RECT.w, MUTE_BUTTON_RECT.h, 15); ctx.fill();
            ctx.globalAlpha = 1.0; ctx.font = `${40 * scaleFactor}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            const emoji = isMuted ? 'ðŸ”‡' : 'ðŸ”Š'; ctx.fillText(emoji, MUTE_BUTTON_RECT.x + MUTE_BUTTON_RECT.w / 2, MUTE_BUTTON_RECT.y + MUTE_BUTTON_RECT.h / 2 + 2);
            ctx.restore();
        }

        function drawInGameInstructions() {
            if (!ingameInstructions.active) return;
            ctx.save(); ctx.globalAlpha = ingameInstructions.opacity; ctx.textAlign = 'center';
            ctx.font = `bold ${32 * scaleFactor}px sans-serif`; ctx.fillStyle = 'white'; ctx.shadowColor = 'black'; ctx.shadowBlur = 8;
            const instructionText = isTouchDevice ? "Tap Left/Right to Move!" : "Use A/D or Arrow Keys to Move!";
            ctx.fillText(instructionText, GAME_WIDTH/2, GAME_HEIGHT * 0.25);
            ctx.restore();
        }
        
        function drawSpecialAbilityNotice() {
            if (!specialAbilityNotice.active) return;
            ctx.save(); ctx.globalAlpha = specialAbilityNotice.opacity; ctx.textAlign = 'center';
            ctx.font = `bold ${32 * scaleFactor}px sans-serif`; ctx.fillStyle = '#FFD700';
            ctx.shadowColor = 'black'; ctx.shadowBlur = 8; ctx.fillText(specialAbilityNotice.text, GAME_WIDTH / 2, GAME_HEIGHT * 0.35);
            ctx.restore();
        }

        function drawUnlockDisplay(startY) {
            if (newlyUnlockedCharacters.length === 0) return 0;
            const textY = startY;
            ctx.font = `bold ${38 * scaleFactor}px sans-serif`; ctx.textAlign = 'center';
            ctx.shadowColor = '#FFFDE7'; ctx.shadowBlur = 15;
            ctx.strokeStyle = '#6D4C41'; ctx.lineWidth = 2.5; ctx.strokeText('New Monkey Unlocked!', GAME_WIDTH / 2, textY);
            ctx.fillStyle = '#FFEB3B'; ctx.fillText('New Monkey Unlocked!', GAME_WIDTH / 2, textY); ctx.shadowBlur = 0;
            const unlockBoxSize = 130 * scaleFactor; const padding = 20 * scaleFactor; const cols = 3;
            const numUnlocks = newlyUnlockedCharacters.length; const rows = Math.ceil(numUnlocks / cols);
            const gridStartY = textY + 50 * scaleFactor;
            let charIndex = 0;
            for (let row = 0; row < rows; row++) {
                const charsInRow = Math.min(cols, numUnlocks - (row * cols));
                const rowWidth = (charsInRow * unlockBoxSize) + Math.max(0, charsInRow - 1) * padding;
                const rowStartX = GAME_WIDTH / 2 - rowWidth / 2;
                for (let col = 0; col < charsInRow; col++) {
                    const char = newlyUnlockedCharacters[charIndex];
                    const charKey = Object.keys(CHARACTERS).find(key => CHARACTERS[key] === char);
                    if (!charKey) { charIndex++; continue; }
                    const boxX = rowStartX + col * (unlockBoxSize + padding); const boxY = gridStartY + row * (unlockBoxSize + padding);
                    ctx.save(); ctx.translate(boxX + unlockBoxSize / 2, boxY + unlockBoxSize / 2);
                    ctx.shadowColor = '#00FFFF'; ctx.shadowBlur = 40;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; ctx.strokeStyle = '#00FFFF'; ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.roundRect(-unlockBoxSize/2, -unlockBoxSize/2, unlockBoxSize, unlockBoxSize, 20 * scaleFactor); ctx.fill(); ctx.stroke();
                    ctx.shadowBlur = 0;
                    drawMonkeyHead(85 * scaleFactor, charKey, -12 * scaleFactor);
                    ctx.font = `bold ${20 * scaleFactor}px sans-serif`; ctx.fillStyle = 'white'; ctx.textAlign = 'center';
                    ctx.shadowColor = 'black'; ctx.shadowBlur = 4; ctx.fillText(char.name, 0, unlockBoxSize/2 - (18 * scaleFactor));
                    ctx.restore(); charIndex++;
                }
            }
            const titleHeight = 50 * scaleFactor; const gridHeight = (rows * unlockBoxSize) + Math.max(0, rows - 1) * padding; const bottomPadding = 20 * scaleFactor;
            return titleHeight + gridHeight + bottomPadding;
        }

        function drawSpotlight() {
            if (selectedGameMode !== 'night') return;

            const monkeyScreenX = monkey.x + monkey.width / 2;
            const monkeyScreenY = monkey.y + monkey.height / 2 - scrollY;

            // --- ADJUST SPOTLIGHT HERE ---

            // 1. Set the size of the bright inner circle.
            const spotlightRadius = 45 * scaleFactor;

            // 2. Set the size of the soft edge (the "feather").
            const featherSize = 100 * scaleFactor;

            // 3. Set the maximum darkness of the unlit areas (0.0 to 1.0).
            // 1.0 is solid black. 0.85 is a good "toned-down" value.
            const maxDarkness = 0.95; // <<< ADJUST THIS VALUE

            // --- End of adjustments ---

            const gradientOuterRadius = spotlightRadius + featherSize;

            const spotlight = ctx.createRadialGradient(
                monkeyScreenX, monkeyScreenY, spotlightRadius,
                monkeyScreenX, monkeyScreenY, gradientOuterRadius
            );

            // The gradient now fades to the `maxDarkness` value instead of solid black.
            spotlight.addColorStop(0, 'rgba(0, 0, 0, 0)');
            spotlight.addColorStop(0.8, `rgba(0, 0, 0, ${maxDarkness * 0.95})`);
            spotlight.addColorStop(1, `rgba(0, 0, 0, ${maxDarkness})`);

            ctx.fillStyle = spotlight;
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        }

        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            const ms = Math.floor((seconds - Math.floor(seconds)) * 100);
            return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
        }
        
        function drawCharacterSelectScreen() {
            skySystem.draw(0.25);
            const baseScale = isTouchDevice ? MOBILE_CHAR_SELECT_SCALE : 1.0;
            const titleY = GAME_HEIGHT * 0.12; const titleSize = 48 * baseScale;
            const titleGrad = ctx.createLinearGradient(0, titleY - titleSize/2, 0, titleY + titleSize/2); titleGrad.addColorStop(0, '#FFFFFF'); titleGrad.addColorStop(1, '#DDDDDD');
            drawAnimatedBeveledLine('Choose Your Monkey!', GAME_WIDTH / 2, titleY, titleSize, titleGrad, 2);
            characterSelectButtons = [];

            const spectralKeys = ['spirit', 'soul', 'ghoul'];
            const checkeredKeys = ['checkers', 'tako', 'ember'];
            const yellowSpecialKeys = ['nanners', 'peeley', 'bruiser'];
            
            const cols = 4; const unlockedCount = unlockedCharacters.length; const rows = Math.ceil(unlockedCount / cols);
            const gridAreaYStart = titleY + titleSize; const gridAreaYEnd = GAME_HEIGHT - (120 * baseScale); const availableGridHeight = gridAreaYEnd - gridAreaYStart;
            const originalBoxSize = 150; const originalPadding = 25;
            const requiredHeight = (rows * originalBoxSize) + Math.max(0, rows - 1) * originalPadding; const verticalFitScale = Math.min(1.0, (availableGridHeight > 0 && requiredHeight > 0) ? availableGridHeight / requiredHeight : 1.0);
            const finalItemScale = baseScale * verticalFitScale; const boxSize = originalBoxSize * finalItemScale; const padding = originalPadding * finalItemScale;
            const totalHeight = rows * boxSize + (rows - 1) * padding; const startY_grid = gridAreaYStart + (availableGridHeight - totalHeight) / 2;
            let charIndex = 0;
            for (let row = 0; row < rows; row++) {
                const charsInRow = Math.min(cols, unlockedCount - (row * cols)); const rowWidth = charsInRow * boxSize + (charsInRow - 1) * padding; const startX_row = GAME_WIDTH / 2 - rowWidth / 2;
                for (let col = 0; col < charsInRow; col++) {
                    const key = unlockedCharacters[charIndex]; if (!key) continue; const char = CHARACTERS[key];
                    const x = startX_row + col * (boxSize + padding); const y = startY_grid + row * (boxSize + padding);
                    
                    ctx.save(); 
                    ctx.translate(x + boxSize / 2, y + boxSize / 2);
                    const wobbleAngle = (Math.sin(charIndex * 0.5 + gameTime * 3)) * 0.035; 
                    ctx.rotate(wobbleAngle);

                    // Common background fill and path definition
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.beginPath();
                    ctx.roundRect(-boxSize/2, -boxSize/2, boxSize, boxSize, 25 * finalItemScale);
                    ctx.fill();

                    // Draw custom borders on the same path
                    if (spectralKeys.includes(key)) {
                        ctx.shadowBlur = 20;
                        if (char.glowRgb) {
                            ctx.shadowColor = `rgba(${char.glowRgb}, ${0.6 + Math.sin(gameTime * 5) * 0.4})`;
                        } else {
                            ctx.shadowColor = char.glowColor || char.solidMain;
                        }
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.85)'; // Spectral black border
                        ctx.lineWidth = 4;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    } else if (checkeredKeys.includes(key)) {
                        ctx.shadowColor = '#6D4C41'; // Banana brown glow
                        ctx.shadowBlur = 15;
                        const bananaYellow = '#FFEB3B';
                        const bananaBrown = '#6D4C41';
                        const borderWidth = 5;
                        const stripeLength = 10 * finalItemScale;

                        // Draw solid brown glowing base
                        ctx.lineWidth = borderWidth;
                        ctx.strokeStyle = bananaBrown;
                        ctx.stroke();

                        // Draw non-glowing yellow dashes on top
                        ctx.shadowBlur = 0;
                        ctx.setLineDash([stripeLength, stripeLength]);
                        ctx.strokeStyle = bananaYellow;
                        ctx.lineCap = 'butt';
                        ctx.stroke();
                        
                        ctx.setLineDash([]);
                        ctx.lineCap = 'round'; // Reset
                    } else if (yellowSpecialKeys.includes(key)) {
                        ctx.shadowColor = '#FFEB3B';
                        ctx.shadowBlur = 15;
                        ctx.strokeStyle = '#FFEB3B';
                        ctx.lineWidth = 3;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    } else if (key === 'rainbow') {
                        ctx.shadowColor = `hsl(${(gameTime * 60) % 360}, 90%, 70%)`;
                        ctx.shadowBlur = 20;
                        const rainbowGrad = ctx.createLinearGradient(-boxSize/2, 0, boxSize/2, 0);
                        rainbowGrad.addColorStop(0, 'red');
                        rainbowGrad.addColorStop(0.2, 'yellow');
                        rainbowGrad.addColorStop(0.4, 'green');
                        rainbowGrad.addColorStop(0.6, 'cyan');
                        rainbowGrad.addColorStop(0.8, 'blue');
                        rainbowGrad.addColorStop(1, 'magenta');
                        ctx.strokeStyle = rainbowGrad;
                        ctx.lineWidth = 4;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    } else { // Default border
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 3; 
                        ctx.stroke();
                    }
                    
                    if (char.sparkles) {
                        ctx.save(); const sparkleCount = 4;
                        for (let i = 0; i < sparkleCount; i++) {
                            let seed = charIndex * 5 + i; const pRNG = () => { let x = Math.sin(seed++) * 10000; return x - Math.floor(x); };
                            const sparklePadding = 15 * finalItemScale; const sparkleX = -boxSize / 2 + sparklePadding + pRNG() * (boxSize - sparklePadding * 2); const sparkleY = -boxSize / 2 + sparklePadding + pRNG() * (boxSize - sparklePadding * 2);
                            const timeOffset = pRNG() * 100; const pulse = Math.sin(gameTime * 3 + timeOffset); const maxRadius = 4 * finalItemScale; const radius = maxRadius * (0.5 + pulse * 0.5);
                            if (radius > 1) {
                                ctx.globalAlpha = 0.5 + pulse * 0.5; ctx.fillStyle = `rgba(255, 255, 224, ${ctx.globalAlpha})`;
                                ctx.beginPath(); ctx.arc(sparkleX, sparkleY, radius, 0, Math.PI * 2); ctx.fill();
                            }
                        }
                        ctx.restore();
                    }
                    
                    drawMonkeyHead(90 * finalItemScale, key, -15 * finalItemScale);
                    
                    ctx.font = `bold ${24 * finalItemScale}px sans-serif`; ctx.fillStyle = 'white'; ctx.textAlign = 'center'; 
                    ctx.fillText(char.name, 0, boxSize/2 - (20 * finalItemScale));
                    
                    ctx.restore(); 
                    characterSelectButtons.push({ x, y, w: boxSize, h: boxSize, key }); charIndex++;
                }
            }
            // START: Modified for mobile button layout
            if (isMobileOrTablet) {
                const btnW = 100 * scaleFactor;
                const btnH = 50 * scaleFactor;
                const btnX = GAME_WIDTH - 110 * scaleFactor;
                const btnY = 15;
                backButtonRect = drawBackButton(btnX, btnY, btnW, btnH, "Back");
            } else {
                const btnW = 320 * baseScale; 
                const btnH = 65 * baseScale; 
                const btnX = GAME_WIDTH / 2 - btnW / 2; 
                const btnY = GAME_HEIGHT - btnH - (isTouchDevice ? 40 : 30) * baseScale;
                backButtonRect = drawBackButton(btnX, btnY, btnW, btnH, "Back to " + (selectedGameMode === 'sprint' ? 'Distances' : 'Modes'));
            }
            // END: Modified for mobile button layout
        }

        function drawSprintSelectScreen() {
            skySystem.draw(0.25);
            drawAnimatedBeveledLine('Summit Sprint', GAME_WIDTH / 2, GAME_HEIGHT * 0.15, 60, '#FFFFFF', 3);
            
            // START: Modified for mobile button layout
            const btnW = isMobileOrTablet ? 400 * scaleFactor : 450 * scaleFactor;
            const btnH = 80 * scaleFactor, spacing = 160 * scaleFactor;
            // END: Modified for mobile button layout
            let currentY = GAME_HEIGHT * 0.35;
            let btnX = GAME_WIDTH/2 - btnW/2;
            
            drawMenuButton("Treetop (10,000m)", btnX, currentY, btnW, btnH);
            menuButtons.sprint10 = { x: btnX, y: currentY, w: btnW, h: btnH };
            currentY += spacing;

            drawMenuButton("Canopy (20,000m)", btnX, currentY, btnW, btnH);
            menuButtons.sprint20 = { x: btnX, y: currentY, w: btnW, h: btnH };
            currentY += spacing;

            drawMenuButton("Summit (30,000m)", btnX, currentY, btnW, btnH);
            menuButtons.sprint30 = { x: btnX, y: currentY, w: btnW, h: btnH };
            
            const backBtnW = 280, backBtnH = 65;
            menuButtons.back = drawBackButton(GAME_WIDTH/2 - backBtnW/2, GAME_HEIGHT - backBtnH - 40, backBtnW, backBtnH, "Return");
            drawMuteButton();
        }

        function render() {
            ctx.clearRect(0,0,canvas.width,canvas.height);

            if (gameState === 'start') {
                skySystem.draw(0.25);
                drawLogo();
                const btnW = 300 * scaleFactor, btnH = 70 * scaleFactor;
                const btnY = isTouchDevice ? 750 : 625; 
                const startX = GAME_WIDTH/2 - btnW/2;
                drawMenuButton("Start Game", startX, btnY, btnW, btnH);
                menuButtons.start = {x:startX, y:btnY, w:btnW, h:btnH};
                ctx.textAlign = 'center'; ctx.font = `bold ${24 * scaleFactor}px sans-serif`; ctx.fillStyle = 'white';
                ctx.shadowColor = 'rgba(0,0,0,0.7)'; ctx.shadowBlur = 5;
                const instructionsY = btnY + btnH + 50 * scaleFactor; const lineHeight = 30 * scaleFactor;
                ctx.fillText("Climb as high as you can!", GAME_WIDTH / 2, instructionsY);
                ctx.fillText("Jump between vines to score points.", GAME_WIDTH / 2, instructionsY + lineHeight);
                ctx.fillText("Collect bananas for a huge bonus!", GAME_WIDTH / 2, instructionsY + lineHeight * 2);
                ctx.shadowBlur = 0; drawMuteButton();

            } else if (gameState === 'modeSelect') {
                skySystem.draw(0.25);
                drawAnimatedBeveledLine('Choose a Mode!', GAME_WIDTH / 2, GAME_HEIGHT * 0.15, 60, '#FFFFFF', 3);
                // START: Modified for mobile button layout
                const btnW = isMobileOrTablet ? 400 * scaleFactor : 450 * scaleFactor;
                const btnH = 80 * scaleFactor, spacing = 160 * scaleFactor;
                // END: Modified for mobile button layout
                let currentY = GAME_HEIGHT * 0.4;
                let btnX = GAME_WIDTH/2 - btnW/2;
                drawMenuButton("Classic Climb", btnX, currentY, btnW, btnH);
                menuButtons.classic = { x: btnX, y: currentY, w: btnW, h: btnH };
                currentY += spacing;
                drawMenuButton("Moonlight Climb", btnX, currentY, btnW, btnH, "Climb in the dark with only a spotlight!");
                menuButtons.night = { x: btnX, y: currentY, w: btnW, h: btnH };
                currentY += spacing;
                drawMenuButton("Summit Sprint", btnX, currentY, btnW, btnH, `Race to the top for the best time!`);
                menuButtons.sprint = { x: btnX, y: currentY, w: btnW, h: btnH };
                const backBtnW = 220, backBtnH = 65;
                menuButtons.back = drawBackButton(GAME_WIDTH/2 - backBtnW/2, GAME_HEIGHT - backBtnH - 40, backBtnW, backBtnH, "Back to Menu");
                drawMuteButton();

            } else if (gameState === 'sprintSelect') {
                drawSprintSelectScreen();

            } else if (gameState === 'characterSelect') {
                drawCharacterSelectScreen();
                drawMuteButton();

            } else { // Game is playing or game over
                const gameClock = (selectedGameMode === 'night') ? 0.8 : (scrollY / DAY_NIGHT_DISTANCE) % 1.0;
                skySystem.draw(gameClock);
                
                particles.forEach(p=>{
                    ctx.save();
                    if(p.type==='leaf'){ctx.fillStyle=`hsl(120,50%,${20+Math.random()*20}%)`;ctx.fillRect(p.x,p.y-scrollY,6,6);}
                    else if(p.type==='sparkle'){ctx.fillStyle=`rgba(255,223,0,${p.l})`;ctx.font=`${22 * scaleFactor}px sans-serif`;ctx.fillText('âœ¨',p.x,p.y-scrollY);}
                    else if(p.type==='monkeySparkle'){ctx.fillStyle=p.color;ctx.beginPath();ctx.arc(p.x,p.y-scrollY,3*p.l,0,2*Math.PI);ctx.fill();}
                    ctx.restore();
                });

                vinePool.forEach(drawVine);
                bananaPool.forEach(drawBanana);
                drawFinishLine();
                monkey.draw();
                drawSpotlight();
                
                drawInGameInstructions();
                drawSpecialAbilityNotice();
                
                ctx.fillStyle='white';ctx.font=`bold ${40 * scaleFactor}px sans-serif`;ctx.textAlign='left';ctx.shadowColor='black';ctx.shadowBlur=5;
                // START: Modified for mobile text layout
                if (selectedGameMode === 'sprint') {
                    if (isMobileOrTablet) {
                        ctx.fillText(`Time: ${formatTime(gameTime)}`, 20, 60 * scaleFactor);
                        ctx.fillText(`Height: ${Math.floor(score)}m / ${sprintTargetHeight}m`, 20, 110 * scaleFactor);
                    } else {
                        ctx.fillText(`Time: ${formatTime(gameTime)}`, 20, 55);
                        ctx.textAlign='right';
                        ctx.fillText(`Height: ${Math.floor(score)}m / ${sprintTargetHeight}m`, GAME_WIDTH - 20, 55);
                    }
                } else {
                    ctx.fillText(`Score: ${Math.floor(score)}`, 20, 55);
                }
                // END: Modified for mobile text layout
                ctx.shadowBlur=0;

                if(gameState === 'gameOver'){
                    ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT);
                    if(isNewHighScore)drawBananaConfetti();

                    const isSprintComplete = selectedGameMode === 'sprint' && finishLine.triggered;
                    const titleText = isSprintComplete ? "Summit Reached!" : "Game Over";
                    ctx.fillStyle='white'; ctx.textAlign='center';
                    ctx.font=`bold ${72 * scaleFactor}px sans-serif`; ctx.fillText(titleText, GAME_WIDTH/2, GAME_HEIGHT*0.15);
                    
                    let textY = GAME_HEIGHT * 0.25;

                    if (selectedGameMode === 'sprint') {
                        ctx.font=`${40 * scaleFactor}px sans-serif`;
                         if (isSprintComplete) {
                            ctx.fillText(`Final Time: ${formatTime(finalTime)}`, GAME_WIDTH/2, textY);
                            textY += 60 * scaleFactor;
                            if(isNewHighScore){ctx.font=`bold ${32 * scaleFactor}px sans-serif`;ctx.fillStyle='#66FF66';ctx.fillText('New Best Time!',GAME_WIDTH/2, textY); textY += 45 * scaleFactor;}
                         } else {
                            ctx.font = `bold ${90 * scaleFactor}px sans-serif`;
                            ctx.shadowColor = 'red';
                            ctx.shadowBlur = 30;
                            ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                            ctx.lineWidth = 2;
                            ctx.strokeText('FAILED!', GAME_WIDTH/2, textY + 20);
                            ctx.fillStyle = '#FF4444';
                            ctx.fillText('FAILED!', GAME_WIDTH/2, textY + 20);
                            ctx.shadowBlur = 0;
                            textY += 80 * scaleFactor;
                         }
                         const unlockDisplayHeight = drawUnlockDisplay(textY); textY += unlockDisplayHeight;
                         if (isNewHighScore || unlockDisplayHeight > 0) textY += 30 * scaleFactor;
                         drawSprintHighScores(GAME_WIDTH/2, textY, sprintTargetHeight);
                    } else { // Classic or Moonlight Climb
                        ctx.font=`${40 * scaleFactor}px sans-serif`;
                        const finalText = 'Final Score: '; const scoreNum = Math.floor(score);
                        const textMetrics = ctx.measureText(finalText); const textWidth = textMetrics.width; const totalWidth = textWidth + ctx.measureText(scoreNum).width; const startX = GAME_WIDTH/2 - totalWidth/2;
                        ctx.fillStyle = 'white'; ctx.textAlign = 'left'; ctx.fillText(finalText, startX, textY);
                        let scoreColor = '#FFFFFF';
                        if (isNewHighScore) {
                            const scores = selectedGameMode === 'classic' ? getHighScores() : getNightHighScores();
                            const rank = scores.indexOf(scoreNum); if (rank > -1) scoreColor = MEDAL_COLORS[rank] || '#FFD700'; else scoreColor = '#66FF66';
                        }
                        ctx.fillStyle = scoreColor; ctx.fillText(scoreNum, startX + textWidth, textY); ctx.textAlign = 'center';
                        textY += 60 * scaleFactor;
                        if(isNewHighScore){ctx.font=`bold ${32 * scaleFactor}px sans-serif`;ctx.fillStyle='#66FF66';ctx.fillText('New High Score!',GAME_WIDTH/2, textY); textY += 45 * scaleFactor;}
                        
                        if (selectedGameMode === 'classic') {
                            const unlockDisplayHeight = drawUnlockDisplay(textY); textY += unlockDisplayHeight;
                            if (isNewHighScore || unlockDisplayHeight > 0) textY += 30 * scaleFactor;
                            drawHighScores(GAME_WIDTH/2, textY);
                        } else { // Night mode
                            const unlockDisplayHeight = drawUnlockDisplay(textY); textY += unlockDisplayHeight;
                            if (isNewHighScore || unlockDisplayHeight > 0) textY += 30 * scaleFactor;
                            drawNightHighScores(GAME_WIDTH/2, textY);
                        }
                    }
                    
                    const btnW = 320 * scaleFactor, btnH = 65 * scaleFactor, spacing = 25 * scaleFactor;
                    const totalBtnHeight = btnH * 2 + spacing;
                    let btnY = GAME_HEIGHT - totalBtnHeight - 50;

                    drawMenuButton("Continue", GAME_WIDTH / 2 - btnW / 2, btnY, btnW, btnH);
                    menuButtons.gameOverContinue = { x: GAME_WIDTH / 2 - btnW / 2, y: btnY, w: btnW, h: btnH };

                    btnY += btnH + spacing;
                    
                    let backBtnText = "Back";
                    if (selectedGameMode === 'sprint') {
                        backBtnText = "Change Distance";
                    } else {
                        backBtnText = "Change Monkey";
                    }
                    menuButtons.gameOverBack = drawBackButton(GAME_WIDTH / 2 - btnW / 2, btnY, btnW, btnH, backBtnText);
                    
                    drawMuteButton();
                }
            }
        }

        function loop(timestamp) {
            dt=Math.min(0.1,(timestamp-lastTime)/1000); lastTime=timestamp;
            update();
            if(gameState==='gameOver' && isNewHighScore)updateConfetti(dt);
            render();
            animationFrameId=requestAnimationFrame(loop);
        }
        
        migrateOldScores(); // Run the one-time migration
        resize();
        loadMuteState();
        checkUnlocks();
        init();
    });
    </script>
</body>
</html>
