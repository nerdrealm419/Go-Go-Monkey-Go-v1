<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- START: Meta tags for app-like full-screen mode on mobile -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- END: Meta tags -->
    <title>Go! Go! Monkey, Go!</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            touch-action: none;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 1200;

        // --- Game Music & Sounds ---
        const bgMusic = new Audio('https://nerdrealm419.github.io/Go-Go-Monkey-Go-v1/jungle-jive-intro.mp3');
        const jumpSound = new Audio('https://nerdrealm419.github.io/Go-Go-Monkey-Go-v1/cartoon-jump-6462.mp3');
        const sparkleSound = new Audio('https://nerdrealm419.github.io/Go-Go-Monkey-Go-v1/sparkle-355937.mp3');
        bgMusic.loop = true;
        bgMusic.volume = 0.0035; // A pleasant background volume
        sparkleSound.volume = 0.004; // Slightly louder than bg music
        jumpSound.volume = 0.004;
        let musicStarted = false;
        let isMuted = false;

        // --- Constants Tuned for better game feel ---
        const MONKEY_ACCELERATION = 750, MONKEY_MAX_SPEED = 330, FRICTION = 0.89, GRAVITY = 1400, JUMP_STRENGTH = 660;
        const VINE_COUNT = 10, VINE_MIN_WIDTH = 140, VINE_MAX_WIDTH = 210, VINE_VERTICAL_SPACING = 125, VINE_FALL_TRIGGER_TIME = 15, VINE_JUMPS_TO_BREAK = 3;
        const VINE_HORIZONTAL_REACH = 220, VINE_FALL_SPEED = 600;
        const BANANA_SPAWN_CHANCE = 0.45, BANANA_POINTS = 750;
        const DAY_NIGHT_DISTANCE = 8600;
        const DIFFICULTY_SCORE_INTERVAL = 8000;
        const VINE_MIN_HORIZONTAL_OFFSET = 80;
        const HIGH_SCORE_KEY = 'gogomonkeygo_highscores';
        const UNLOCK_KEY = 'gogomonkeygo_highestscore';
        const MUTE_KEY = 'gogomonkeygo_muted';
        const MUTE_BUTTON_RECT = { x: GAME_WIDTH - 70, y: 15, w: 55, h: 55 };
        const MEDAL_COLORS = ['#FFD700', '#C0C0C0', '#CD7F32', '#00FFFF', '#FF69B4'];
        const MEDAL_EMOJIS = ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰', 'ðŸ…', 'ðŸ…'];
        
        const CHARACTERS = {
            'orange':  { name: 'Go!Go!',   unlock: 0,      main: '#f96714', dark: '#ef5a06', face: '#ffdab9', pupils: '#000000' },
            'peach': { name: 'Peachy',  unlock: 15000,   main: '#ffb74d', dark: '#f57c00', face: '#fff3e0', pupils: '#000000' },
            'brown':   { name: 'CoCo',    unlock: 20000,   main: '#623412', dark: '#401801', face: '#d1bba1', pupils: '#000000' },
            'red':    { name: 'Ruby',   unlock: 25000,   main: '#d32f2f', dark: '#b71c1c', face: '#ffcdd2', pupils: '#000000' },
            'yellow':  { name: 'Sunny',   unlock: 27500,  main: '#dbc001', dark: '#fbc02d', face: '#fff9c4', pupils: '#000000' },
            'pink':    { name: 'Rose',    unlock: 30000,  main: '#f48fb1', dark: '#c2185b', face: '#fce4ec', pupils: '#e91e63' },
            'blue':    { name: 'Azul',    unlock: 35000,  main: '#42a5f5', dark: '#1565c0', face: '#bbdefb', pupils: '#0277bd' },
            'purple':  { name: 'Violet',  unlock: 40000,  main: '#971597', dark: '#6a1b9a', face: '#f6bbf6', pupils: '#320732' },
            'gray':    { name: 'Silver',  unlock: 50000,  main: '#9e9e9e', dark: '#616161', face: '#e0e0e0', pupils: '#000000', sparkles: true },
            'black':   { name: 'Shadow',  unlock: 60000,  main: '#424242', dark: '#212121', face: '#757575', pupils: '#000000', sparkles: true },
            'white':   { name: 'Arctic',  unlock: 70000,  main: '#bfc7d6', dark: '#8a99b4', face: '#dadee7', pupils: '#596b8b', sparkles: true},
            'green':   { name: 'Emerald', unlock: 75000,  main: '#028f1e', dark: '#027919', face: '#c8e6c9', pupils: '#01400e', sparkles: true, shine: true },
            'gold':    { name: 'Goldie',  unlock: 100000,  main: '#dcba00', dark: '#7a6700', face: '#fff9c4', pupils: '#524500', sparkles: true, shine: true },
            'diamond': { name: 'Diamond', unlock: 150000,  main: '#b9f2ff', dark: '#81d4fa', face: '#e1f5fe', pupils: '#0277bd', sparkles: true, shine: true },
            'rainbow': { name: 'Rainbow', unlock: 200000, face: '#ffffff', pupils: '#000000', isRainbow: true, sparkles: true, shine: true },
        };
        let selectedCharacterKey = 'orange';
        let unlockedCharacters = ['orange'];
        let newlyUnlockedCharacter = null;
        let characterSelectButtons = [];

        let scale = 1, offsetX = 0, offsetY = 0;

        // --- Audio Management ---
        function playSound(sound) {
            if (!isMuted) {
                sound.currentTime = 0;
                sound.play().catch(e => console.warn('Sound playback failed', e));
            }
        }
        
        function loadMuteState() {
            isMuted = localStorage.getItem(MUTE_KEY) === 'true';
        }

        function saveMuteState() {
            localStorage.setItem(MUTE_KEY, isMuted);
        }

        function ensureMusicIsPlaying() {
            if (isMuted) {
                bgMusic.pause();
                return;
            }
            if (!musicStarted) {
                const promise = bgMusic.play();
                if (promise !== undefined) {
                    promise.then(_ => { musicStarted = true; }).catch(error => {
                        console.warn('Music could not be started yet (requires user gesture):', error);
                    });
                }
            } else if (bgMusic.paused) {
                bgMusic.play().catch(e => console.warn('Resuming music failed.', e));
            }
        }
        
        function toggleMute() {
            isMuted = !isMuted;
            saveMuteState();
            ensureMusicIsPlaying();
        }

        // Unlock audio context on the first click anywhere.
        document.addEventListener('click', () => {
            if (!musicStarted) ensureMusicIsPlaying();
        }, { once: true });


        function resize() {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;

            // Calculate the best scale to fit the game within the window, preserving aspect ratio.
            scale = Math.min(windowWidth / GAME_WIDTH, windowHeight / GAME_HEIGHT);
            
            // Set the canvas display size. The CSS flex properties will center it.
            canvas.style.width = `${GAME_WIDTH * scale}px`;
            canvas.style.height = `${GAME_HEIGHT * scale}px`;
            
            // Set the internal canvas resolution. This never changes.
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            
            // Recalculate offsets for mouse/touch coordinates.
            const rect = canvas.getBoundingClientRect();
            offsetX = rect.left;
            offsetY = rect.top;

            if (skySystem) skySystem.init(true);
        }
        window.addEventListener('resize', resize);
        
        function screenToCanvasCoords(screenX, screenY) {
            return {
                x: (screenX - offsetX) / scale,
                y: (screenY - offsetY) / scale
            };
        }

        let lastTime = 0, gameState = 'start', scrollY = 0, score = 0, gameTime = 0, animationFrameId;
        let isNewHighScore = false;
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        let ingameInstructions = { active: false, opacity: 1.0, hasMoved: false };
        const menuButtons = { start: null };

        const keys = {a:0,d:0,ArrowLeft:0,ArrowRight:0};
        window.addEventListener('keydown', e=>{if(keys.hasOwnProperty(e.key)) { keys[e.key]=1; if(gameState === 'playing' && !ingameInstructions.hasMoved) ingameInstructions.hasMoved = true; } if((gameState==='start'||gameState==='gameOver')&&(e.key===' '||e.key==='Enter'))startGameSequence();});
        window.addEventListener('keyup', e=>{if(keys.hasOwnProperty(e.key))keys[e.key]=0;});
        
        let activeTouches = {};

        function updateMovementKeysFromTouches() {
            let goLeft = false;
            let goRight = false;
            for (const id in activeTouches) {
                if (activeTouches[id] === 'left') goLeft = true;
                if (activeTouches[id] === 'right') goRight = true;
            }
            if (goRight) {
                keys.d = 1; keys.ArrowRight = 1;
                keys.a = 0; keys.ArrowLeft = 0;
            } else if (goLeft) {
                keys.a = 1; keys.ArrowLeft = 1;
                keys.d = 0; keys.ArrowRight = 0;
            } else {
                keys.a = 0; keys.d = 0; keys.ArrowLeft = 0; keys.ArrowRight = 0;
            }
        }

        function handleInteraction(screenX, screenY) {
            const { x, y } = screenToCanvasCoords(screenX, screenY);
            
            // Handle mute button clicks first on relevant screens
            if (['start', 'characterSelect', 'gameOver'].includes(gameState)) {
                if (x > MUTE_BUTTON_RECT.x && x < MUTE_BUTTON_RECT.x + MUTE_BUTTON_RECT.w && y > MUTE_BUTTON_RECT.y && y < MUTE_BUTTON_RECT.y + MUTE_BUTTON_RECT.h) {
                    toggleMute();
                    return; // Interaction handled
                }
            }

            if (gameState === 'start') {
                const startBtn = menuButtons.start;
                if (startBtn && x > startBtn.x && x < startBtn.x + startBtn.w && y > startBtn.y && y < startBtn.y + startBtn.h) {
                    startGameSequence();
                }
            } else if (gameState === 'characterSelect') {
                for(const btn of characterSelectButtons) {
                    if (x > btn.x && x < btn.x + btn.w && y > btn.y && y < btn.y + btn.h) {
                        selectedCharacterKey = btn.key;
                        initializeLevel();
                    }
                }
            } else if (gameState === 'gameOver') {
                init();
            }
        }
        
        const handleTouchStart = (e) => {
             e.preventDefault();
             const changed = e.changedTouches;
             if (['start', 'characterSelect', 'gameOver'].includes(gameState)) {
                 handleInteraction(changed[0].clientX, changed[0].clientY);
                 return;
             }
             if (ingameInstructions.active && !ingameInstructions.hasMoved) { ingameInstructions.hasMoved = true; }
             for (let i = 0; i < changed.length; i++) {
                 const touch = changed[i];
                 activeTouches[touch.identifier] = touch.clientX < window.innerWidth / 2 ? 'left' : 'right';
             }
             updateMovementKeysFromTouches();
        };
        const handleTouchMove = (e) => {
            e.preventDefault();
            if (gameState !== 'playing') return;
            const changed = e.changedTouches;
            for (let i = 0; i < changed.length; i++) {
                const touch = changed[i];
                if (activeTouches.hasOwnProperty(touch.identifier)) {
                    activeTouches[touch.identifier] = touch.clientX < window.innerWidth / 2 ? 'left' : 'right';
                }
            }
            updateMovementKeysFromTouches();
        };
        const handleTouchEnd = (e) => {
            e.preventDefault();
            const changed = e.changedTouches;
            for (let i = 0; i < changed.length; i++) {
                const touch = changed[i];
                delete activeTouches[touch.identifier];
            }
            updateMovementKeysFromTouches();
        };

        canvas.addEventListener('click', (e) => { if (!isTouchDevice) handleInteraction(e.clientX, e.clientY); });
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });

        const particles = [], vinePool = [], bananaPool = [], bananaConfetti = [];

        const skySystem = {
            stars: [], clouds: [], shootingStars: [],
            generateCloudPuffs() {
                const puffs = []; const puffCount = Math.floor(Math.random() * 4) + 5; const baseWidth = (Math.random() * 100 + 130);
                for (let i = 0; i < puffCount; i++) { puffs.push({ dx: (Math.random() - 0.5) * baseWidth * 0.8, dy: (Math.random() - 0.5) * 33, r: (Math.random() * 0.4 + 0.6) * (baseWidth / (puffCount/2.5)) }); }
                return { puffs, baseWidth };
            },
            init(isResize = false) {
                if(isResize && this.stars.length > 0) return;
                this.stars = []; this.clouds = []; this.shootingStars = [];
                for(let i=0; i<300; i++) this.stars.push({x:Math.random()*GAME_WIDTH,y:Math.random()*GAME_HEIGHT,z:Math.random()*0.5+0.1,b:Math.random()*0.8+0.2});
                for(let i=0; i<20; i++) {
                    const cloudData = this.generateCloudPuffs();
                    this.clouds.push({x: Math.random()*GAME_WIDTH, y: Math.random()*GAME_HEIGHT, z: Math.random()*0.5+0.2, w: cloudData.baseWidth, puffs: cloudData.puffs});
                }
            },
            update(dt, nightlight) {
                this.clouds.forEach(c => { c.x += 20 * c.z * dt; if(c.x - c.w > GAME_WIDTH) c.x = -c.w * 2; });
                if (nightlight > 0.6 && Math.random() < 0.004) { this.shootingStars.push({ x: Math.random() * GAME_WIDTH * 1.2, y: Math.random() * GAME_HEIGHT * 0.4, len: (Math.random() * 200 + 160), speed: (Math.random() * 530 + 660), life: 1.2, angle: Math.PI * 0.35 + Math.random() * 0.1 }); }
                this.shootingStars.forEach((s, i) => { s.x -= s.speed * dt; s.y += s.speed * Math.tan(s.angle) * dt; s.life -= dt; if (s.life <= 0) this.shootingStars.splice(i, 1); });
            },
            draw(gameClock) {
                const daylight = 0.5 - Math.cos(gameClock * 2 * Math.PI) * 0.5; const nightlight = 1 - daylight;
                const topH=205+35*daylight, topS=50+40*daylight, topL=10+55*daylight; const botH=220+20*daylight, botS=50+20*daylight, botL=25+45*daylight;
                const grad=ctx.createLinearGradient(0,0,0,GAME_HEIGHT); grad.addColorStop(0,`hsl(${topH},${topS}%,${topL}%)`); grad.addColorStop(1,`hsl(${botH},${botS}%,${botL}%)`);
                ctx.fillStyle=grad; ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT);
                ctx.globalAlpha = nightlight * 0.9;
                this.stars.forEach(s=>{ctx.fillStyle=`rgba(255,255,255,${s.b*(0.5+Math.sin(Date.now()*s.z/1000)*0.5)})`;ctx.beginPath();ctx.arc(s.x,(s.y-scrollY*s.z)%GAME_HEIGHT,s.z*2,0,2*Math.PI);ctx.fill();});
                this.shootingStars.forEach(s => { const tailX = s.x + s.len; const tailY = s.y - s.len * Math.tan(s.angle); const starGrad = ctx.createLinearGradient(s.x, s.y, tailX, tailY); starGrad.addColorStop(0, `rgba(255, 255, 224, ${s.life})`); starGrad.addColorStop(1, 'rgba(255, 255, 224, 0)'); ctx.strokeStyle = starGrad; ctx.lineWidth = 3.3; ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(tailX, tailY); ctx.stroke(); });
                ctx.globalAlpha = daylight * 0.9;
                this.clouds.forEach(c => this.drawFluffyCloud(c));
                ctx.globalAlpha = 1;
            },
            drawFluffyCloud(c) {
                const parallaxY = (c.y - scrollY * c.z); const screenHeightWithBuffer = GAME_HEIGHT + c.w * 2; const wrappedY = (parallaxY % screenHeightWithBuffer + screenHeightWithBuffer) % screenHeightWithBuffer - c.w;
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 * c.z})`; ctx.beginPath();
                c.puffs.forEach(p => { ctx.moveTo(c.x + p.dx, wrappedY + p.dy); ctx.arc(c.x + p.dx, wrappedY + p.dy, p.r, 0, Math.PI * 2); });
                ctx.fill();
            }
        };
        
        const monkey = {
            x:0,y:0,vx:0,vy:0,width:40,height:40,squash:1,onGround:false, headAngle:0,
            leftArmAngle: 0, rightArmAngle: 0, attachedHearts: [], heartEyesTimer: 0,
            isBlinking: false, blinkTimer: 2 + Math.random() * 4, blinkDuration: 0,
            isScared: false,

            update(dt) {
                const move=(keys.ArrowRight||keys.d)-(keys.ArrowLeft||keys.a); this.vx+=move*MONKEY_ACCELERATION*dt;
                this.vx*=FRICTION; this.x+=this.vx*dt; this.vy+=GRAVITY*dt; this.y+=this.vy*dt;
                if(this.x>GAME_WIDTH)this.x=-this.width;if(this.x+this.width<0)this.x=GAME_WIDTH;
                if (this.vy > JUMP_STRENGTH * 0.4) this.isScared = true;
                
                let targetRightArmAngle, targetLeftArmAngle;
                if (this.vy < 0) {
                    const upRatio = Math.min(1, Math.abs(this.vy / (JUMP_STRENGTH * 0.9)));
                    const UP_V_ANGLE = 2.7, T_POSE_ANGLE = Math.PI / 2;
                    targetRightArmAngle = -T_POSE_ANGLE - (UP_V_ANGLE - T_POSE_ANGLE) * upRatio;
                    targetLeftArmAngle =  T_POSE_ANGLE + (UP_V_ANGLE - T_POSE_ANGLE) * upRatio;
                } else {
                    targetRightArmAngle = -Math.PI / 2; targetLeftArmAngle = Math.PI / 2;
                }
                const lerpSpeed = 10;
                this.rightArmAngle += (targetRightArmAngle - this.rightArmAngle) * lerpSpeed * dt;
                this.leftArmAngle += (targetLeftArmAngle - this.leftArmAngle) * lerpSpeed * dt;

                this.headAngle=(this.headAngle*0.9)+(this.vx/MONKEY_MAX_SPEED*0.8*0.1);
                this.squash=this.onGround?(this.squash*0.8+1.2*0.2):(this.squash*0.8+1.0*0.2); this.onGround=false;
                
                this.blinkTimer -= dt;
                if (this.blinkTimer <= 0 && !this.isBlinking) { this.isBlinking = true; this.blinkDuration = 0.15; }
                if (this.isBlinking) { this.blinkDuration -= dt; if (this.blinkDuration <= 0) { this.isBlinking = false; this.blinkTimer = 2 + Math.random() * 4; } }
                this.attachedHearts.forEach((h, i) => { h.life -= dt; if (h.life <= 0) this.attachedHearts.splice(i, 1); });
                if (this.heartEyesTimer > 0) { this.heartEyesTimer -= dt; }
                
                const char = CHARACTERS[selectedCharacterKey];
                if (char.sparkles && Math.random() < 0.3) {
                    const color = char.shine ? `rgba(255, 215, 0, ${Math.random() * 0.5 + 0.5})` : `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.5})`;
                    particles.push({
                        x: this.x + Math.random() * this.width, y: this.y + Math.random() * this.height,
                        vx: (Math.random() - 0.5) * 20, vy: (Math.random() - 0.5) * 20, l: Math.random() * 0.5 + 0.3, type: 'monkeySparkle', color: color
                    });
                }
            },
            draw() { drawMonkeyAt(this.x, this.y - scrollY, selectedCharacterKey, this); },
            jump(){this.vy=-JUMP_STRENGTH;this.squash=0.7; playSound(jumpSound); },
            land(){ this.onGround=true; this.squash=1.4; this.isScared = false; },
            collectBanana(){
                this.heartEyesTimer = 0.4; this.attachedHearts.length = 0;
                for(let i=0; i<5; i++) {
                    const angle = Math.random() * Math.PI * 2; const dist = 30 + Math.random() * 20;
                    this.attachedHearts.push({
                        ox: Math.cos(angle) * dist, oy: Math.sin(angle) * dist - this.height/2,
                        life: Math.random() * 0.5 + 0.5, maxLife: 1.0, size: (Math.random() * 8 + 8),
                    });
                }
            }
        };

        function drawMonkeyHead(x, y, size, charKey) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(size / monkey.width, size / monkey.width);
            const char = CHARACTERS[charKey];
            
            let mainColor = char.main;
            if (char.isRainbow) {
                const hue = (performance.now() / 20) % 360;
                mainColor = `hsl(${hue}, 90%, 60%)`;
            }
            ctx.fillStyle = mainColor;
            
            ctx.beginPath(); ctx.arc(16, -6, 10, 0, 2 * Math.PI); ctx.arc(-16, -6, 10, 0, 2 * Math.PI); ctx.fill();
            ctx.beginPath(); ctx.arc(0, 0, 22, 0, 2 * Math.PI); ctx.fill();
            ctx.fillStyle = char.face; ctx.beginPath(); ctx.ellipse(0, 2, 18, 16, 0, 0, 2 * Math.PI); ctx.fill();
            drawEye(char, -6, -2, false, false, false, 0); drawEye(char, 6, -2, false, false, false, 0);
            ctx.strokeStyle = char.dark || '#000'; ctx.lineWidth = 2; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(-4, 7); ctx.quadraticCurveTo(0, 9, 4, 7); ctx.stroke();
            ctx.restore();
        }
        
        function drawMonkeyAt(x, y, charKey, state) {
            ctx.save(); ctx.translate(x + state.width/2, y + state.height/2);
            const char = CHARACTERS[charKey];
            const bodyW=state.width*(2-state.squash), bodyH=state.height*state.squash;
            
            let mainColor = char.main;
            let darkColor = char.dark;

            if (char.isRainbow) {
                const hue = (gameTime * 60) % 360;
                mainColor = `hsl(${hue}, 90%, 60%)`;
                darkColor = `hsl(${hue}, 70%, 30%)`;
            }

            drawTail(state, darkColor);
            const legAngle=Math.sin(Date.now()/200)*0.1-state.vy/2000;
            drawLeg(-bodyW/4,bodyH/4,legAngle,mainColor); drawLeg(bodyW/4,bodyH/4,legAngle,mainColor);
            
            if (char.shine) {
                const shineGrad = ctx.createLinearGradient(-bodyW/2, -bodyH/2, bodyW/2, bodyH/2);
                const shinePos = (Math.sin(gameTime * 4) + 1) / 2;
                const shineColor = charKey === 'diamond' ? '#e3f2fd' : 'white';
                const shineWidth = 0.1; // Controls how wide the shine band is
                shineGrad.addColorStop(Math.max(0, shinePos - shineWidth), mainColor);
                shineGrad.addColorStop(shinePos, shineColor);
                shineGrad.addColorStop(Math.min(1, shinePos + shineWidth), mainColor);
                ctx.fillStyle = shineGrad;
            } else {
                ctx.fillStyle=mainColor;
            }
            ctx.beginPath(); ctx.roundRect(-bodyW/2,-bodyH/2,bodyW,bodyH,12); ctx.fill();

            ctx.save(); ctx.translate(0,-bodyH/2 - 12*state.squash); ctx.rotate(state.headAngle);
            ctx.fillStyle=mainColor; ctx.beginPath();ctx.arc(16,-6,10,0,2*Math.PI);ctx.arc(-16,-6,10,0,2*Math.PI);ctx.fill();
            ctx.fillStyle=mainColor; ctx.beginPath();ctx.arc(0,0,22,0,2*Math.PI);ctx.fill();
            ctx.fillStyle=char.face; ctx.beginPath();ctx.ellipse(0, 2, 18, 16, 0, 0, 2*Math.PI);ctx.fill();
            
            drawEye(char, -6, -2, state.heartEyesTimer > 0, state.isScared, state.isBlinking, state.headAngle);
            drawEye(char, 6, -2, state.heartEyesTimer > 0, state.isScared, state.isBlinking, state.headAngle);
            
            ctx.strokeStyle=darkColor; ctx.lineWidth=2; ctx.lineCap='round'; ctx.beginPath();
            if (state.isScared) {
                ctx.moveTo(-6, 9); ctx.quadraticCurveTo(-2, 6, 0, 9); ctx.quadraticCurveTo(2, 12, 6, 9);
            } else if (state.vy < -210) {
                ctx.ellipse(0, 8, 3, 5, 0, 0, 2 * Math.PI);
            } else {
                ctx.moveTo(-4, 7); ctx.quadraticCurveTo(0, 9, 4, 7);
            }
            ctx.stroke();

            state.attachedHearts.forEach(h => {
                ctx.save(); ctx.globalAlpha = Math.max(0, h.life / h.maxLife);
                ctx.font = `${h.size}px sans-serif`; ctx.textAlign = 'center';
                ctx.fillText('â¤ï¸', h.ox, h.oy); ctx.restore();
            });
            ctx.restore(); 
            drawSwingingArm(-bodyW / 2 + 8, -bodyH / 4, state.leftArmAngle, mainColor);
            drawSwingingArm(bodyW / 2 - 8, -bodyH / 4, state.rightArmAngle, mainColor);
            ctx.restore();
        }

        function drawEye(char, x, y, isHeart, isScared, isBlinking, headAngle) {
            if (isHeart) {
                ctx.font = `bold 8px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('â¤ï¸', x, y);
            } else if (isScared) {
                ctx.strokeStyle = char.dark || '#000'; ctx.lineWidth = 2; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(x - 4, y); ctx.lineTo(x + 4, y); ctx.stroke();
            } else if (isBlinking) {
                ctx.strokeStyle = char.dark || '#000'; ctx.lineWidth = 2; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(x - 4, y); ctx.lineTo(x + 4, y); ctx.stroke();
            } else {
                ctx.fillStyle = 'white'; ctx.strokeStyle = '#a79a95'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.arc(x, y, 5.5, 0, 2 * Math.PI); ctx.fill(); ctx.stroke();
                ctx.fillStyle = char.pupils; ctx.beginPath();
                ctx.arc(x + headAngle * 4, y, 2.8, 0, 2 * Math.PI); ctx.fill();
            }
        }
        function drawLeg(x,y,a,c){ctx.save();ctx.translate(x,y);ctx.rotate(a);ctx.strokeStyle=c;ctx.lineWidth=10;ctx.lineCap='round';ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(0,16);ctx.stroke();ctx.restore();}
        function drawSwingingArm(x, y, angle, color) {
            ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
            ctx.lineCap = 'round'; ctx.strokeStyle = color; ctx.lineWidth = 8;
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 20); ctx.stroke();
            ctx.fillStyle = color; ctx.beginPath(); ctx.arc(0, 20, 6, 0, 2 * Math.PI); ctx.fill();
            ctx.restore();
        }
        function drawTail(state, color) {
            const bodyBottomY = state.height / 2 - 6; const sway = Math.sin(gameTime * 12) * 10; const lift = Math.max(0, -state.vy * 0.05);
            const startY = bodyBottomY - lift * 0.5;
            const cp1 = { x: sway, y: startY + 22 - lift }; const cp2 = { x: -sway, y: startY + 38 - lift * 0.5 };
            const end = { x: sway * 0.3, y: startY + 50 - lift * 0.2 };
            ctx.strokeStyle = color; ctx.lineWidth = 6; ctx.lineCap = 'round';
            ctx.beginPath(); ctx.moveTo(0, startY); ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y); ctx.stroke();
        }
        
        function getHighScores(){try{const s=JSON.parse(localStorage.getItem(HIGH_SCORE_KEY));return Array.isArray(s)?s:[];}catch(e){return[];}}
        function saveHighScores(s){localStorage.setItem(HIGH_SCORE_KEY,JSON.stringify(s));}
        function getHighestScore() { return parseInt(localStorage.getItem(UNLOCK_KEY) || '0', 10); }
        function checkUnlocks() {
            const highestScore = getHighestScore();
            unlockedCharacters = ['orange'];
            for (const key in CHARACTERS) {
                if (key !== 'orange' && highestScore >= CHARACTERS[key].unlock) {
                    unlockedCharacters.push(key);
                }
            }
        }
        function updateScores(newScore) {
            if(newScore <= 0) return { isNewHighScore: false, newUnlock: null };
            let newUnlock = null;
            const oldHighest = getHighestScore();
            if (newScore > oldHighest) {
                localStorage.setItem(UNLOCK_KEY, Math.floor(newScore));
                for (const key in CHARACTERS) {
                    if (newScore >= CHARACTERS[key].unlock && oldHighest < CHARACTERS[key].unlock) {
                        newUnlock = CHARACTERS[key];
                    }
                }
            }
            const scores = getHighScores();
            const lowest = scores.length < 5 ? 0 : scores[scores.length - 1];
            let isNewHighScore = false;
            if (newScore > lowest) {
                scores.push(Math.floor(newScore));
                scores.sort((a,b)=>b-a);
                saveHighScores(scores.slice(0,5));
                isNewHighScore = true;
            }
            return { isNewHighScore, newUnlock };
        }
        
        function spawnBananaConfetti(){bananaConfetti.length=0;for(let i=0;i<60;i++)bananaConfetti.push({x:Math.random()*GAME_WIDTH,y:-Math.random()*GAME_HEIGHT,vx:(Math.random()-.5)*73,vy:Math.random()*106+40,a:Math.random()*Math.PI*2,r:(Math.random()-.5)*5,s:(Math.random()*13+13)});}
        function updateConfetti(dt){const g=146;bananaConfetti.forEach(p=>{p.vy+=g*dt;p.x+=p.vx*dt;p.y+=p.vy*dt;p.a+=p.r*dt;});}
        function drawBananaConfetti(){bananaConfetti.forEach(p=>{ctx.save();ctx.translate(p.x,p.y);ctx.rotate(p.a);ctx.font=`${p.s}px sans-serif`;ctx.textAlign='center';ctx.fillText('ðŸŒ',0,0);ctx.restore();});}
        
        function drawHighScores(x, y) {
            const scores = getHighScores(); if (scores.length === 0) return;
            ctx.textAlign = 'center'; ctx.font = `bold 36px sans-serif`;
            ctx.fillStyle = 'white'; ctx.fillText('High Scores', x, y);
            ctx.font = `30px sans-serif`;
            scores.forEach((s, i) => {
                const scoreY = y + (i + 1) * 45;
                const medalText = MEDAL_EMOJIS[i] ? `${MEDAL_EMOJIS[i]} ` : `${i + 1}. `;
                ctx.fillStyle = MEDAL_COLORS[i] || 'white';
                ctx.fillText(`${medalText}${s}`, x, scoreY);
            });
            ctx.fillStyle = 'white';
        }

        function getDifficultyLevel(currentScore) { return Math.floor(currentScore / DIFFICULTY_SCORE_INTERVAL); }

        function createVine(y, prevVine, currentScore = 0) {
            const difficulty = getDifficultyLevel(currentScore);
            const widthReduction = difficulty * 9.3;
            const currentMaxWidth = Math.max(VINE_MIN_WIDTH * 0.7, VINE_MAX_WIDTH - widthReduction);
            const currentMinWidth = Math.max(VINE_MIN_WIDTH * 0.6, VINE_MIN_WIDTH - widthReduction);
            const width = currentMinWidth + Math.random() * (currentMaxWidth - currentMinWidth);
            const jumpsLeft = Math.max(2, VINE_JUMPS_TO_BREAK - Math.floor(difficulty / 2.0));
            let x;

            if (prevVine) {
                const prevVineCenterX = prevVine.x + prevVine.width / 2;
                const leftZone_end = prevVineCenterX - VINE_MIN_HORIZONTAL_OFFSET;
                const leftZone_start = prevVineCenterX - VINE_HORIZONTAL_REACH;
                const rightZone_start = prevVineCenterX + VINE_MIN_HORIZONTAL_OFFSET;
                const rightZone_end = prevVineCenterX + VINE_HORIZONTAL_REACH;

                const leftZone_size = Math.max(0, leftZone_end - leftZone_start);
                const rightZone_size = Math.max(0, rightZone_end - rightZone_start);
                const totalZone_size = leftZone_size + rightZone_size;

                let newVineCenterX;
                if (totalZone_size <= 0) {
                    newVineCenterX = GAME_WIDTH / 2;
                } else {
                    const rand = Math.random() * totalZone_size;
                    if (rand < leftZone_size) {
                        newVineCenterX = leftZone_start + rand;
                    } else {
                        newVineCenterX = rightZone_start + (rand - leftZone_size);
                    }
                }
                x = newVineCenterX - width / 2;
                const margin = 15;
                x = Math.max(margin, x);
                x = Math.min(x, GAME_WIDTH - width - margin);
            } else { 
                x = Math.random() * (GAME_WIDTH - width); 
            }
            
            const leaves=[];for(let i=0;i<width/14.5;i++){leaves.push({x:Math.random()*width,y:Math.random()*6.5-3.3,s:Math.random()*4+4,a:Math.random()*Math.PI,color:`hsl(120,50%,${25+Math.random()*20}%)`});}
            return {x,y,width,leaves,jumpsLeft:jumpsLeft,isFalling:false,dip:0};
        }
        
        function drawVine(vine) {
            vine.dip*=0.8; const drawY=vine.y-scrollY+vine.dip;
            ctx.save();
            if (vine.isFalling) { const fadeStart=GAME_HEIGHT*0.9,fadeEnd=GAME_HEIGHT*1.2;if(drawY>fadeStart){ctx.globalAlpha=1-(drawY-fadeStart)/(fadeEnd-fadeStart);} }
            ctx.translate(vine.x,drawY);
            const p1={x:0,y:10},p2={x:vine.width,y:10},cp={x:vine.width/2,y:10+vine.dip/2};
            ctx.strokeStyle='#3e2723';ctx.lineWidth=14;ctx.lineCap='round';ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.quadraticCurveTo(cp.x,cp.y,p2.x,p2.y);ctx.stroke();
            ctx.strokeStyle='#5d4037';ctx.lineWidth=10;ctx.beginPath();ctx.moveTo(p1.x,p1.y);ctx.quadraticCurveTo(cp.x,cp.y,p2.x,p2.y);ctx.stroke();
            ctx.strokeStyle='#8d6e63';ctx.lineWidth=4;ctx.beginPath();ctx.moveTo(p1.x,p1.y-1);ctx.quadraticCurveTo(cp.x,cp.y-1,p2.x,p2.y-1);ctx.stroke();
            vine.leaves.forEach(l=>{ctx.save();ctx.translate(l.x,l.y+10);ctx.rotate(l.a);ctx.fillStyle=l.color;ctx.beginPath();ctx.ellipse(0,0,l.s,l.s/2,0,0,2*Math.PI);ctx.fill();ctx.restore();});
            ctx.restore();
        }

        function drawBanana(b) {
            if(b.isCollected)return; const glow=0.6+Math.sin(Date.now()/200)*0.4;
            ctx.save(); ctx.shadowBlur=20;ctx.shadowColor=`rgba(255,223,0,${glow})`;
            ctx.fillStyle='white';ctx.font=`32px sans-serif`;ctx.textAlign='center';
            ctx.fillText('ðŸŒ',b.x,b.y-scrollY); ctx.restore();
        }
        
        function init() {
            gameState = 'start';
            if (!animationFrameId) {
                lastTime = performance.now();
                dt = 0;
                loop(lastTime);
            }
        }

        function startGameSequence() {
            checkUnlocks();
            if (unlockedCharacters.length > 1) {
                gameState = 'characterSelect';
            } else {
                selectedCharacterKey = 'orange';
                initializeLevel();
            }
        }

        function initializeLevel() {
            ensureMusicIsPlaying();
            scrollY=0;score=0;gameTime=0;gameState='playing';particles.length=0; isNewHighScore=false; newlyUnlockedCharacter=null; bananaConfetti.length=0; monkey.attachedHearts.length = 0;
            monkey.x=GAME_WIDTH/2-monkey.width/2;monkey.y=GAME_HEIGHT-150;monkey.vx=0;monkey.vy=0;
            monkey.isScared = false;
            ingameInstructions = { active: true, opacity: 1.0, hasMoved: false };
            vinePool.length=0;bananaPool.length=0;let lastVine=null;
            for(let i=0;i<VINE_COUNT;i++){const v=createVine(GAME_HEIGHT-100-i*VINE_VERTICAL_SPACING,lastVine,0);vinePool.push(v);lastVine=v;}
            vinePool[0].x=monkey.x+monkey.width/2-vinePool[0].width/2;vinePool[0].y=monkey.y+monkey.height+10;
        }

        let dt = 0;
        function update() {
            gameTime+=dt; 

            if (gameState === 'playing') {
                monkey.update(dt);
                if (ingameInstructions.active && ingameInstructions.hasMoved) {
                    ingameInstructions.opacity -= 2.0 * dt;
                    if (ingameInstructions.opacity <= 0) {
                        ingameInstructions.active = false;
                    }
                }
            }
            else if (['start', 'characterSelect'].includes(gameState)) { 
                skySystem.update(dt, 0.5); 
                return; 
            }
            
            const gameClock = (scrollY / DAY_NIGHT_DISTANCE) % 1.0; const nightlight = 1 - (0.5 - Math.cos(gameClock * 2 * Math.PI) * 0.5);
            skySystem.update(dt, nightlight);

            if(monkey.vy>0){for(const v of vinePool){if(!v.isFalling&&monkey.x+monkey.width>v.x&&monkey.x<v.x+v.width&&monkey.y+monkey.height+monkey.vy*dt>v.y&&monkey.y+monkey.height<=v.y+20){monkey.y=v.y-monkey.height;monkey.jump();monkey.land();v.dip=15;if(gameTime>VINE_FALL_TRIGGER_TIME){v.jumpsLeft--;if(v.jumpsLeft<=0){v.isFalling=true; for(let i=0;i<5;i++)particles.push({x:v.x+Math.random()*v.width,y:v.y,vx:(Math.random()-0.5)*40,vy:Math.random()*40,l:2,type:'leaf'});}} break;}}}
            for(const b of bananaPool){if(!b.isCollected&&Math.hypot(monkey.x+monkey.width/2-b.x,monkey.y+monkey.height/2-b.y)<50){b.isCollected=true;score+=BANANA_POINTS;monkey.collectBanana();playSound(sparkleSound);for(let i=0;i<15;i++)particles.push({x:b.x,y:b.y,vx:(Math.random()-0.5)*185,vy:(Math.random()-0.5)*185,l:1,type:'sparkle'});}}
            
            const scrollThr=GAME_HEIGHT*0.4;if(monkey.y-scrollY<scrollThr){const s=(monkey.y-scrollY)-scrollThr;scrollY+=s;score+=Math.floor(-s);}
            particles.forEach((p,i)=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.l-=dt;if(p.l<=0)particles.splice(i,1);});
            
            vinePool.forEach((v) => {
                if (v.isFalling) { v.y += VINE_FALL_SPEED * dt; }
                if (v.y -scrollY > GAME_HEIGHT + 40) {
                    let highestVine = null; let highestY = Infinity;
                    for (const otherVine of vinePool) { if (otherVine.y < highestY) { highestY = otherVine.y; highestVine = otherVine; } }
                    const difficulty = getDifficultyLevel(score), spacingIncrease = difficulty * 5.3, newSpacing = VINE_VERTICAL_SPACING + spacingIncrease;
                    Object.assign(v, createVine(highestY - newSpacing, highestVine, score));
                    if (score > 1000 && Math.random() < BANANA_SPAWN_CHANCE) { bananaPool.push({x: v.x + v.width/2, y: v.y - 50, isCollected: false}); }
                }
            });

            bananaPool.forEach((b,i)=>{if(b.y-scrollY>GAME_HEIGHT+40)bananaPool.splice(i,1);})
            
            if(monkey.y-scrollY>GAME_HEIGHT){
                if(gameState==='playing'){
                    const scoreResult = updateScores(score);
                    isNewHighScore = scoreResult.isNewHighScore;
                    newlyUnlockedCharacter = scoreResult.newUnlock;
                    if(isNewHighScore) spawnBananaConfetti();
                }
                gameState='gameOver';
            }
        }
        
        function drawAnimatedBeveledLine(text, x, y, size, mainFill, bevelOffset) {
            ctx.font = `bold ${size}px 'Comic Sans MS', 'Chalkduster', sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const textMetrics = ctx.measureText(text);
            let currentX = x - textMetrics.width / 2;
            const highlightColor = 'rgba(255, 255, 255, 0.4)';
            const shadowColor = 'rgba(0, 0, 0, 0.25)';

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const charMetrics = ctx.measureText(char);
                const charX = currentX + charMetrics.width / 2;
                
                ctx.save();
                ctx.translate(charX, y);
                ctx.rotate((Math.sin(i * 0.8 + gameTime * 3)) * 0.1);

                ctx.fillStyle = highlightColor;
                ctx.fillText(char, -bevelOffset, -bevelOffset);
                ctx.fillStyle = shadowColor;
                ctx.fillText(char, bevelOffset, bevelOffset);

                ctx.strokeStyle = '#4a2d1e';
                ctx.lineWidth = size / 10;
                ctx.lineJoin = 'round';
                ctx.strokeText(char, 0, 0);

                ctx.fillStyle = mainFill;
                ctx.fillText(char, 0, 0);

                ctx.restore();
                currentX += charMetrics.width;
            }
        }

        function drawLogo() {
            const baseY = 280; // Adjusted for better centering
            const lineSpacing = 120;

            const size1 = 110;
            const grad1 = ctx.createLinearGradient(0, baseY - size1/2, 0, baseY + size1/2);
            grad1.addColorStop(0, '#f9f954'); grad1.addColorStop(1, '#e3c600');
            drawAnimatedBeveledLine('Go! Go!', GAME_WIDTH / 2, baseY, size1, grad1, 4);

            const size2 = 100;
            const y2 = baseY + lineSpacing;
            const grad2 = ctx.createLinearGradient(0, y2 - size2/2, 0, y2 + size2/2);
            grad2.addColorStop(0, CHARACTERS.orange.main);
            grad2.addColorStop(1, CHARACTERS.orange.dark);
            drawAnimatedBeveledLine('Monkey,', GAME_WIDTH / 2, y2, size2, grad2, 3);
            
            const y3 = baseY + lineSpacing * 2;
            drawAnimatedBeveledLine('Go!', GAME_WIDTH / 2, y3, size1, grad1, 4);
        }
        
        function drawMenuButton(text, x, y, w, h) {
            const grad = ctx.createLinearGradient(x, y, x, y + h);
            grad.addColorStop(0, 'hsl(120, 60%, 45%)'); grad.addColorStop(1, 'hsl(120, 60%, 30%)');
            ctx.fillStyle = grad;
            ctx.strokeStyle = 'hsl(120, 80%, 85%)'; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.roundRect(x, y, w, h, 20); ctx.fill(); ctx.stroke();
            ctx.fillStyle = 'white'; ctx.font = `bold 36px sans-serif`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 6;
            ctx.fillText(text, x + w/2, y + h/2 + 2);
            ctx.shadowBlur = 0;
        }

        function drawMuteButton() {
            ctx.save();
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.roundRect(MUTE_BUTTON_RECT.x, MUTE_BUTTON_RECT.y, MUTE_BUTTON_RECT.w, MUTE_BUTTON_RECT.h, 15);
            ctx.fill();
            ctx.globalAlpha = 1.0;
            ctx.font = '40px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const emoji = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
            ctx.fillText(emoji, MUTE_BUTTON_RECT.x + MUTE_BUTTON_RECT.w / 2, MUTE_BUTTON_RECT.y + MUTE_BUTTON_RECT.h / 2 + 2);
            ctx.restore();
        }

        function drawInGameInstructions() {
            if (!ingameInstructions.active) return;
            ctx.save();
            ctx.globalAlpha = ingameInstructions.opacity;
            ctx.textAlign = 'center';
            ctx.font = `bold 32px sans-serif`;
            ctx.fillStyle = 'white';
            ctx.shadowColor = 'black'; ctx.shadowBlur = 8;
            const instructionText = isTouchDevice ? "Tap Left/Right to Move!" : "Use A/D or Arrow Keys to Move!";
            ctx.fillText(instructionText, GAME_WIDTH/2, GAME_HEIGHT * 0.25);
            ctx.restore();
        }
        
        function drawCharacterSelectScreen() {
            skySystem.draw(0.25);
            
            // Draw wobbly title
            const titleY = GAME_HEIGHT * 0.15;
            const titleSize = 48;
            const titleGrad = ctx.createLinearGradient(0, titleY - titleSize/2, 0, titleY + titleSize/2);
            titleGrad.addColorStop(0, '#FFFFFF'); 
            titleGrad.addColorStop(1, '#DDDDDD');
            drawAnimatedBeveledLine('Choose Your Monkey!', GAME_WIDTH / 2, titleY, titleSize, titleGrad, 2);
            
            characterSelectButtons = [];
            const cols = 3;
            const unlockedCount = unlockedCharacters.length;
            const rows = Math.ceil(unlockedCount / cols);
            const boxSize = 160, padding = 30;
            const totalWidth = cols * boxSize + (cols-1) * padding;
            const totalHeight = rows * boxSize + (rows-1) * padding;
            const startX = GAME_WIDTH/2 - totalWidth/2;
            const startY = GAME_HEIGHT/2 - totalHeight/2;

            unlockedCharacters.forEach((key, i) => {
                const char = CHARACTERS[key];
                const col = i % cols;
                const row = Math.floor(i / cols);
                const x = startX + col * (boxSize + padding);
                const y = startY + row * (boxSize + padding);

                ctx.save();
                // Translate to center of box to rotate around it
                ctx.translate(x + boxSize / 2, y + boxSize / 2);
                const wobbleAngle = (Math.sin(i * 0.5 + gameTime * 3)) * 0.035; // Apply a gentle wobble
                ctx.rotate(wobbleAngle);

                // Draw everything relative to the new (0,0) center
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.roundRect(-boxSize/2, -boxSize/2, boxSize, boxSize, 25);
                ctx.fill(); ctx.stroke();
                
                // Draw monkey head centered
                drawMonkeyHead(0, -15, 100, key);
                
                // Draw text centered
                ctx.font = 'bold 26px sans-serif';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.fillText(char.name, 0, boxSize/2 - 25);
                ctx.restore();
                
                // The button hitbox is unaffected by the visual wobble
                characterSelectButtons.push({ x, y, w: boxSize, h: boxSize, key });
            });
        }


        function render() {
            ctx.clearRect(0,0,canvas.width,canvas.height);

            if (gameState === 'start') {
                skySystem.draw(0.25);
                drawLogo();
                const btnW = 300, btnH = 70, btnY = 625; // Adjusted for better centering
                const startX = GAME_WIDTH/2 - btnW/2;
                drawMenuButton("Start Game", startX, btnY, btnW, btnH);
                menuButtons.start = {x:startX, y:btnY, w:btnW, h:btnH};
                drawMuteButton();
            } else if (gameState === 'characterSelect') {
                drawCharacterSelectScreen();
                drawMuteButton();
            } else {
                const gameClock = (scrollY / DAY_NIGHT_DISTANCE) % 1.0;
                skySystem.draw(gameClock);
                
                particles.forEach(p=>{
                    ctx.save();
                    if(p.type==='leaf'){ctx.fillStyle=`hsl(120,50%,${20+Math.random()*20}%)`;ctx.fillRect(p.x,p.y-scrollY,6,6);}
                    else if(p.type==='sparkle'){ctx.fillStyle=`rgba(255,223,0,${p.l})`;ctx.font=`22px sans-serif`;ctx.fillText('âœ¨',p.x,p.y-scrollY);}
                    else if(p.type==='monkeySparkle'){ctx.fillStyle=p.color;ctx.beginPath();ctx.arc(p.x,p.y-scrollY,3*p.l,0,2*Math.PI);ctx.fill();}
                    ctx.restore();
                });

                vinePool.forEach(drawVine);
                bananaPool.forEach(drawBanana);
                monkey.draw();
                
                drawInGameInstructions();
                
                ctx.fillStyle='white';ctx.font=`bold 40px sans-serif`;ctx.textAlign='left';ctx.shadowColor='black';ctx.shadowBlur=5;
                ctx.fillText(`Score: ${Math.floor(score)}`, 20, 55);
                ctx.shadowBlur=0;

                if(gameState!=='playing'){
                    ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT);
                    if(gameState==='gameOver'&&isNewHighScore)drawBananaConfetti();
                    ctx.fillStyle='white'; ctx.textAlign='center';
                    ctx.font=`bold 72px sans-serif`; ctx.fillText('Game Over', GAME_WIDTH/2, GAME_HEIGHT*0.15);
                    
                    ctx.font=`40px sans-serif`;
                    const finalScoreText = 'Final Score: '; const scoreNumber = Math.floor(score);
                    const textMetrics = ctx.measureText(finalScoreText); const textWidth = textMetrics.width;
                    const totalWidth = textWidth + ctx.measureText(scoreNumber).width;
                    const startX = GAME_WIDTH/2 - totalWidth/2;

                    ctx.fillStyle = 'white'; ctx.textAlign = 'left';
                    ctx.fillText(finalScoreText, startX, GAME_HEIGHT*0.25);

                    let scoreColor = '#FFFFFF';
                    if (isNewHighScore) {
                        const highScores = getHighScores(); const rank = highScores.indexOf(scoreNumber);
                        if (rank > -1) scoreColor = MEDAL_COLORS[rank] || '#FFD700';
                        else scoreColor = '#66FF66';
                    }
                    ctx.fillStyle = scoreColor;
                    ctx.fillText(scoreNumber, startX + textWidth, GAME_HEIGHT*0.25);
                    ctx.textAlign = 'center'; 

                    let textY = GAME_HEIGHT*0.32;
                    if(isNewHighScore){ctx.font=`bold 32px sans-serif`;ctx.fillStyle='#66FF66';ctx.fillText('New High Score!',GAME_WIDTH/2, textY); textY += 45;}
                    if(newlyUnlockedCharacter){
                        ctx.font=`bold 32px sans-serif`; ctx.fillStyle='#00FFFF';
                        ctx.fillText(`You unlocked the ${newlyUnlockedCharacter.name} monkey!`, GAME_WIDTH/2, textY);
                    }

                    drawHighScores(GAME_WIDTH/2, GAME_HEIGHT*0.42);
                    
                    ctx.font=`bold 30px sans-serif`;
                    ctx.fillStyle='white';
                    const playAgainText = isTouchDevice ? 'Tap anywhere to Continue' : 'Click or Press Space to Continue';
                    ctx.fillText(playAgainText, GAME_WIDTH/2, GAME_HEIGHT - 80);
                    drawMuteButton();
                }
            }
        }

        function loop(timestamp) {
            dt=Math.min(0.1,(timestamp-lastTime)/1000); lastTime=timestamp;
            update();
            if(gameState==='gameOver' && isNewHighScore)updateConfetti(dt);
            render();
            animationFrameId=requestAnimationFrame(loop);
        }
        
        resize();
        loadMuteState();
        checkUnlocks();
        init();
    });
    </script>
</body>
</html>
